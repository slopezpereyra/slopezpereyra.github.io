---
title: An application of formal language theory to the detection of NREM sleep
categories: [ Science ]
---

Assume that, given a series of sleep stages, we define a NREM period as any
sequence of stages satisfying that:

- the total duration of NREM periods $2$, $3$ or $4$ in the sequence is $15$
  minutes or more;
- the sequence may contain REM or waking stages that do not last $5$ minutes or
  more;
- the sequence ends with either $a.$ 5 minutes or more of REM or $b.$ $5$
  minutes or more of wakefulness. 


(See, if curious about where this definition comes from, [Feinberg &
Floyed](https://pubmed.ncbi.nlm.nih.gov/220659/) or search for papers by Dijk.)

We ask for an algorithm that maps a sequence of stages $s_1, \ldots, s_n$, with
$s_i$ the sleep stage of the $i$th epoch, to $k$ vectors $\varrho_1, \ldots,
\varrho_k$, where $\varrho_i = (\varrho_i^1, \ldots, \varrho_i^z)$ is s.t.
$\varrho_{i}^{j}$ is the $j$th epoch in the $i$th NREM period. (This implies
$\varrho_i^j \in \mathbb{N}$ for all $i, j \in \mathbb{N}$). In other words, we
ask for an algorithm that detects that $k$ underlying NREM periods in the
staging of a night of sleep, and provides a characterization of each them 
consisting of the epochs which comprise them.

Let us assume that:which


Let $\Sigma = \\{1, 2, 3, 4, 5, 6\\}$ an alphabet where $1, \ldots, 4$ denote the
homonimous sleep stages, $5$ denotes REM and $6$ denotes wakefulness. Then the
succession $s_1, \ldots, s_n$ may be treated as a word $\alpha \in \Sigma^{*}$
of the form 

$$
\alpha = \psi_1 \beta_1 \psi_2 \beta_2 \ldots \psi_k\beta_k \psi_{k+1}
$$

where $\psi_i$ is an arbitrary word and

$$
\beta_i = \varphi (5^M5^* | 6)
$$

with $\varphi \in \\{ w \in \\{2, 3, 4\\}^+ : |w| \geq N \\}$, $N$ the minimum
duration imposed for NREM periods, $M$ the minimum duration imposed for ending
REM periods. Thus, the problem of finding the $k$ underlying NREM periods 
in a series of sleep stages becomes the problem of finding the $k$ substrings
$\beta_1, \ldots, \beta_k$ of $\alpha$. This problem is trivial from an 
implementation perspective, since programming languages include regular expressions 
natively.


Subtleties, such as not imposing a minimum duration to the ending REM period 
of the first NREM period, can easily be adapted into the regular expression of each $\beta_i$.

For example, in Julia, 

```julia 
function nrem(staging::Vector, n::Integer, m::Integer)
    """
    nrem(eeg::EEG, n::Integer, m::Integer)

    This function finds all NREM periods in a stage vector. It returns a list [ [a₁, b₁], …, [aₖ, bₖ] ] s.t. 
    each of the k NREM periods of the EEG range between epochs [aᵢ, bᵢ], i ∈ ℕ.

    Given a sequence s₁, …, sₖ of sleep stages, s.t. sᵢ is the stage of the ith epoch in an EEG,
    we define the alphabet Σ = {s : s ∈ {s₁, …, sₙ})}. We assume Σ = {1, 2, 3, 4, 5, 6}, with 5 denoting 
    REM and 6 denoting wakefulness. If α = s₁… sₙ ∈ Σ*, we assume α can be decomposed into the form 

                                α = ψ₁β₁ …  ψₖβₖ ψₖ₊₁ 

    where ψᵢ is an arbitrary word and βᵢ is a word of the form 

                                φ(5ᵐ5* + 6),   φ ∈ { w ∈ {2, 3, 4}* : |w| ≥ n }

    Here, n is the minimum length imposed upon combinations of stages 2, 3, and 4, in order to account for a NREM period,
    while m is the minimum length imposed upon REM periods terminating NREM periods.

    Thus, βᵢ can be thought of as a NREM period, and the set φ(5ᵐ5* + 6) as the universe of NREM periods.
    """
    φ = Regex("[234]{$n,}(?:6|5{$(m+1),})")
    α = join(staging, "")
    matches = eachmatch(φ, α)
    return [ [match.offset, match.offset + length(match.match)] for match in matches ]
end

```









