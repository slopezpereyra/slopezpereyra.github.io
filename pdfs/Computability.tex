\documentclass[a4paper, 12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{newtxtext} \usepackage{newtxmath}
\usepackage{amsmath, amssymb}
\newtheorem{problem}{Problem}
\newtheorem{example}{Example}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{problem}{Problem}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}

\newenvironment{rcases}
  {\left.\begin{aligned}}
  {\end{aligned}\right\rbrace}

\begin{document}

\begin{titlepage}
   \begin{center}
       \vspace*{1cm}

       \textbf{Computability theory}

       \small
       \vspace{0.5cm}
        FAMAF - UNC
            
       \vspace{1.5cm}
       \footnotesize
       \textbf{SLP}
       \normalsize

       \vfill
            
            
     
   \end{center}
\end{titlepage}


\tableofcontents
\newpage

\section{Introduction}

These are my notes on computability theory. The only definitions that ought to
be known first-hand are the following.

Let $\Sigma$ denote an arbitrary language, $\omega := \mathbb{N} + \{
0\}$, and $n, m \geq 0$ fixed elements in $\omega$. Then: 

\begin{itemize}
    \item A $\Sigma$-mixed function is a function s.t. $\mathcal{D}_f \subseteq
        \omega^n \times \Sigma^{*m} \mapsto \varphi$ with either $\varphi =
        \omega$ or $\varphi = \Sigma^{*}$.
    \item A $\Sigma$-mixed function is $\Sigma$-effectively computable if we can
        find some algorithmic procedure that, given an input in $\omega^n \times
        \Sigma^{*m}$, outputs the value of $f(\overrightarrow{x},
        \overrightarrow{\alpha})$. 
    \item Any set $S \subseteq \omega^{n} \times \Sigma^{*m}$ is termed a
        $\Sigma$-mixed set. 
    \item If there is an algorithmic procedure that enumerates $S$, we say $S$
        is $\Sigma$-effectively enumerable. 

    \item If there is an algorithmic procedure that decides the belonging to
        $S$, we say $S$ is $\Sigma$-effectively computable.
\end{itemize}

Here, the notion of "algorithmic procedure" is non-rigorous. The principal
subject of this study are three formalizations of this concept: Turing
computability, recursive computability (Godel), and imperative
computability (von Neumann).

\pagebreak

\section{Coding infinite tuples}

We define $\omega^{\mathbb{N}} := \{ (s_1, s_2, \ldots) : s_i \in \omega \}$ and
$\omega^{\left[ \mathbb{N} \right] } \subseteq \omega^{\mathbb{N}} := \{(s_1,
s_2, \ldots) : s_i \in \omega \land \exists k \in \omega : i \geq k
\Rightarrow s_i = 0\}$. 

\subsection{The $i$th prime function}

We define 

\begin{align*}
    pr : \mathbb{N} &\mapsto \omega  \\ 
    n &\mapsto \text{ the $n$th prime number}
\end{align*}

\begin{theorem}
    For all $x \in \mathbb{N}$ there is a unique infinituple $\overrightarrow{s}
    \in \omega^{[\mathbb{N}]}$ s.t. 

    \begin{align*}
        x = \prod_{i=1}^{\infty} pr(i)^{s_i}
    \end{align*}
\end{theorem}

The theorem follows trivially from the definition of $\omega^{[\mathbb{N}]}$ and
the fundamental theorem of arithmetic. 


\small
\begin{quote}

\begin{problem}
    Prove the previous theorem via complete induction.
\end{problem}

The base case is trivial. Assume the statement holds for all $n \leq k$. The
fundamental theorem of arithmetic ensures that $k + 1 = p_1 \cdot \ldots \cdot
p_m$ where $p_i$ is prime. Assume the factorization above is ordered (this is,
$p_{j + 1} > p_j$ for all $j \in [1, m]$). Then $k + 1 = p_m \cdot q$ with $q =
p_1 \cdot \ldots \cdot p_{m - 1}$. 

\footnotesize
\begin{quote}
    \textit{Subproof.} We will prove $k + 1 = p_m \cdot q \Rightarrow q \leq k$.
    Assume the premise holds and the consequence does not. Since $q > k$ we have
    $q \cdot x > k + 1$ for all $x > 1$. Then $q \cdot x > k + 1$ for all $x$
    that is prime. Then $q \cdot p_m \neq k + 1$ which is a contradiction. Then,
    if $k + 1 = q \cdot p_m$, we have $q \leq k$. $\blacksquare$
\end{quote}
\small

Since $q \leq k$, via inductive hypothesis, $q$ takes the productorial form of
the theorem above. Then $k + 1 = q \cdot pr(j)$ where $pr(j) = p_m$. Then the
theorem holds for all $n \in \mathbb{N}$.

\end{quote}
\normalsize


\begin{theorem}
    If $p, p_1, \ldots, p_m$ are prime ($m \geq 1$) and $p \mid p_1 \ldots p_m$,
    then $p = p_i$ for some $i$.
\end{theorem}

We use $\left\langle  s_1, s_2, \ldots  \right\rangle$ to denote the number $x =
\prod_{n=1}^{\infty} pr(n)^{s_n}$. We use $(x)_i$ to denote $s_i$ in said tuple
and $(x)$ to denote the infinituple itself.

\begin{theorem}
    The functions 

    \begin{align*}
        \mathbb{N} &\mapsto \omega^{[\mathbb{N}]} &
        \omega^{[\mathbb{N}]}&\mapsto \mathbb{N} \\  
        x &\mapsto (x) = \left( (x)_1, (x)_2, \ldots \right) & (s_1, s_2,
        \ldots)&\mapsto \left\langle  s_1, s_2,\ldots  \right\rangle
    \end{align*}

    are bijections each the inverse of the other.
\end{theorem}

The theorem should be intuitive. The function that maps a number $x$ to the
infinituple of its prime exponents is the inverse of the function which takes an
infinituple and maps it to the product of its prime factors with the
corresponding exponents.

\begin{theorem}
    $$(x)_i = \max_{t} \left( pr(i)^{t} \mid x \right) $$
\end{theorem}

We define 

\begin{align*}
    Lt : \mathbb{N} &\mapsto \omega \\ 
    x &\mapsto \begin{cases}
        \max_{i} ~ (x)_i \neq 0 & x \neq 1 \\ 
        0 & x = 1
    \end{cases}
\end{align*}

The function returns the index of the maximum prime factor (that is not
zero-exponentiated) in the factorization of $x$. Since, in this factorizations,
all prime factors beyond $Lt(x)$ are zero, $Lt(x)$ can be understood as an
upper-bound of the factorization. This is formalized in the following theorem.

\begin{theorem}
    \begin{align*}
        x = \prod_{i=1}^{Lt(x)}  pr(i)^{(x)_i}
    \end{align*}
\end{theorem}


\small
\begin{quote}


\begin{problem}
    Prove the previous theorem.
\end{problem}

We know $x = \prod_{i=1}^{\infty} pr(i)^{(x)_i}  $ where $(x) \in
\omega^{[\mathbb{N}]}$. Then, by definition, there is some $k \in \omega$ s.t. $(x)_i = 0$
if $i \geq k$. Then $x = \prod_{i=1}^{k - 1} pr(i)^{(x)_i} \times \prod_{i=k}^{\infty}
pr(i)^{0} = \prod_{i=1}^{k-1} pr(i)^{(x)_i}     $

We want to prove $k - 1 = Lt(x)$. However, this follows from definition, since
we have defined $k - 1$ to be the maximum value after which all $(x)_{j > k -1}
= 0$. Then $k - 1 = Lt(x)$. $\blacksquare$


\end{quote}
\normalsize

Prime numbers closely relate to set enumerability. The reason is that the prime
decomposition of a number associates to any unique $x \in \mathbb{N}$ an
infinite number of inters $(x)_1, (x)_2, \ldots$. Thus, say we want to generate
all possible pairs $(x, y, z) \in \omega^3$ given a unique input $x \in
\mathbb{N}$. Then, letting $(x, y, z) = \left( (x)_1, (x)_2, (x)_3 \right) $, we
have 

\begin{align*}
    x = 1 &\mapsto (0, 0, 0)\\ 
    x = 2 &\mapsto (1, 0, 0)\\
    x = 3 &\mapsto (0, 1, 0)\\
    x = 4 &\mapsto (2, 0, 0)\\
    x = 5 &\mapsto (0, 0, 1)\\
    x = 6 &\mapsto (1, 1, 0)\\ 
    x = 7 &\mapsto (0, 0, 0)\\
    x = 8 &\mapsto (3, 0, 0)\\
    x = 9 &\mapsto (0, 2, 0)\\ 
      &\vdots
\end{align*}

It is easy to see that any $(x, y, z) \in \omega^3$ is reached. This generalizes
to $\omega^n, n \in \omega$ and to $\omega^{n} \times \Sigma^{*m} $ via the
$*^{\leq}$ function (which we shall study in the following section).

\subsection{Orders over $\Sigma$}

Let $\Sigma$ an alphabet with $n$ symbols. We want to find a bijection between $\omega$ and
$\Sigma^{*}$ assuming some order $\leq$ over $\Sigma$. Let $s^{\leq} :
\Sigma^{*} \mapsto \Sigma^{*}$ be


\begin{align*}
    s^{\leq} \left( (a_n)^m \right)  &= (a_1)^{m + 1} & m \geq 0\\ 
    s^{\leq} \left( \alpha a_i (a_n)^{m} \right) &= \alpha a_{i+1} (a_1)^{m} & 1
    \leq i < n, m \geq 0
\end{align*}

This function enumerates the language ordered $\Sigma$. For example, consider
$\Sigma = \{@, !\}$ with $@ < !$. Then 

\begin{align*}
    s^{\leq}( \varepsilon ) &= s^{\leq}( !^{0} ) = @\\
    s^{\leq}( @ ) &= s^{\leq}( \varepsilon @ (!)^{0} ) = \varepsilon ! \varepsilon = ~!
    \\ 
    \vdots
\end{align*}

Repeated application of this logic outputs the following enumeration: 

\begin{align*}
    @, !, @@, @!, !@, !!, @@@, @@!, @!@, @!!, !@@, !@!, !!@, !!!, \ldots
\end{align*}

The reason why $s^{\leq}( \beta  )$ enumerates the language is that every $\beta
$ is either of the form $(a_n)^{m}$ or $\alpha a_i (a_n)^{m}$. This is, it is
either a word with only the last character to a certain exponent, or a word with
some subchain before the last character to a certain exponent.

Now we are ready to define a bijection between $\omega$ and $\Sigma^{*}$. Let 

\begin{align*}
    *^{\leq} : \omega &\mapsto \Sigma^{*} \\ 
    x &\mapsto \begin{cases}
        \varepsilon & x = 0 \\ 
        s^{\leq} \left( *^{\leq} \left( i \right)  \right) & x = i + 1
    \end{cases}
\end{align*}

For example, using the same alphabet as before, this function maps 

\begin{align*}
    0 &\mapsto \varepsilon \\ 
    1 &\mapsto @ \\ 
    2 &\mapsto ! \\ 
    3 &\mapsto @@ \\ 
    4 &\mapsto @! \\ 
    5 &\mapsto !@ \\ 
    6 &\mapsto  !! \\ 
    7 &\mapsto  @@@ \\ 
      &\vdots
\end{align*}

Now, observe that any $\alpha \in \Sigma^{*}$ is a concatenation of unique
symbols, and that each of this unique symbols is the $i$th element of
$\Sigma^{*}$ for some $i$. We write to express this $\alpha = a_{i_k}\ldots
a_{i_0}$ where $i_{k}, i_{k-1}, \ldots, i_{k_0} \in \{ 1, \ldots, n\}$. Then we
define the inverse of the previous function as follows: 

\begin{align*}
    \#^{\leq} : \Sigma^{*} &\mapsto \omega \\ 
    \varepsilon & \mapsto 0 \\ 
    a_{i_k} \ldots a_{i_0} &\mapsto i_k n^{k} + \ldots + i_0 n^0
\end{align*}

For example, consider $\alpha = @!@ = a_{1} a_2 a_1$. Then $\#^{\leq}( \alpha )
= 1 \times 2^2 + 2 \times 2^1 + 1 \times 2^0 = 4 + 4 + 1 = 9$. It is easy to
verify that $*^{\leq}( 9 ) = @!@$.

Thus, the functions given produce a perfect bijection between numbers and words.
Each word can be univocally determined by its numeric position in the language;
each number can be univocally determined by a word whose position in the
language is that number. 

\begin{theorem}
    Let $n \geq 1$. Then any $x \in \mathbb{N}$ is uniquely written as $x = i_k
    n^k + i_{k-1} n^{k-1} + \ldots + i_0 n_^0$ with $k \geq 0, 1 \leq i_j \leq
    n$ for all $j$.
\end{theorem}

\subsection{Extending the order to words}

We can extend $\leq$ from $\Sigma$ onto $\Sigma^{*}$ by letting $\alpha \leq
\beta $ if and only if $\#^{\leq}(\alpha) \leq \#^{(\leq)}(\beta )$.

\pagebreak


\section{Enumerable and computable sets}

Let $\mathcal{F} : \mathcal{D}_{\mathcal{F}} \subseteq \omega^{k} \times \Sigma^{*l} \to \omega^n
\times \Sigma^{*m}$. We define $\mathcal{F}_{(i)} = p_i^{n, m} \circ
\mathcal{F}$. Then

\begin{align*}
    \mathcal{F}_{(i)} &: \mathcal{D}_{\mathcal{F}} \subseteq \omega^{k} \times
    \Sigma^{*l}  \mapsto \omega & 1 \leq i \leq n\\
    \mathcal{F}_{(i)} &: \mathcal{D}_{\mathcal{F}} \subseteq \omega^{k} \times
    \Sigma^{*l} \mapsto  \Sigma^{*} & n + 1 \leq i \leq m
\end{align*}

We say a set $S \subseteq \omega^n \times \Sigma^{*m} $ is $\Sigma$-effectively
enumerable  if it is empty or there is a function $\mathcal{F} : \omega \to
\omega^n \times \Sigma^{*m}$ s.t. $Im_{\mathcal{F}} = S$ and $\mathcal{F}_{(i)}$
is $\Sigma$-computable for all $1 \leq i \leq n + m$.

\begin{theorem}
    A non-empty set $S \subseteq \omega^n \times \Sigma^{*m}$ is
    $\Sigma$-effectively enumerable if and only if there is an effective
    procedure $\mathcal{P}$ s.t. 

    \begin{itemize}
        \item The input space is $\omega$
        \item $\mathcal{P}$ halts for all $x \in \omega$ 
        \item The output set is $S$---i.e. whenever $\mathcal{P}$ halts, it
            outputs an element of $S$, and for every $(\overrightarrow{x},
            \overrightarrow{\alpha}) \in S$ there is some input $x \in \omega$
        s.t. $\mathcal{P}(x) \mapsto_{\text{halting}} (\overrightarrow{x},
        \overrightarrow{\alpha})$.
    \end{itemize}
\end{theorem}

\small
\begin{quote}

\begin{problem}
    Let $F : \left\{ (x, \alpha) \in  \omega \times \Sigma^{*} : |\alpha|^x
        \equiv 0 \mod 2
    \right\} \mapsto \omega^2 \times \Sigma^{*}$ be defined as follows: 

    \begin{align*}
        F(x, \alpha) = (x, x^2 + |\alpha|, \varepsilon)
    \end{align*}

    Provide $F_{(1)}, F_{(2)}, F_{(3)}$. What function is $[F_{(1)}, F_{(2)},
    F_{(3)}]$?
\end{problem}

By definition, $F_{(i)} = p_i^{1, 1} \circ F$. Then 

\begin{align*}
    F_{(1)}(x, \alpha) &= x \\
    F_{(2)}(x, \alpha) &= x + |\alpha| \\
    F_{(3)}(x, \alpha) &= \varepsilon
\end{align*}

It is evident that the composition given results in $F$.

\begin{problem}
    Prove that $F = \left[ F_{(1)}, \ldots, F_{(n + m)} \right] $.
\end{problem}

Let $G := \left[ F_{(1)}, \ldots, F_{(n+m)} \right] $. 

$\therefore $  $G(\vec{x}, \vec{\alpha}) = \left( p_1^{n, m} \circ F(\vec{x},
\vec{\alpha}), \ldots, p_{n+m} \circ F(\vec{x}, \vec{\alpha})   \right)  =
F(\vec{x}, \vec{\alpha}) $ $\blacksquare$



\end{quote}
\normalsize

\begin{theorem}
    Let $S \subseteq \omega^{n} \times \Sigma^{*m} $. The following statements are equivalent. 

    \textit{(1)} $S$ is $\Sigma$-effectively enumerable. 

    \textit{(2)} $S$ is the domain of a $\Sigma$-effectively computable function
    $f$.  

    \textit{(3)} $S$ is the image of a function $F: \mathcal{D}_f \subseteq
    \omega^{n} \times \Sigma^{*m} \mapsto S$ s.t. each $F_{(i)}$ is
    $\Sigma$-effectively computable.
\end{theorem}

That $(1) \Leftrightarrow (3)$ is trivial. $(1) \Leftrightarrow (2)$ can be proven as
follows. 


\small
\begin{quote}

\textbf{Proof.} $(\Rightarrow)$. Assume $S$ is $\Sigma$-effectively enumerable.
Then there is a procedure $\mathbb{P}$ s.t. for any $x \in  \omega$ the
procedure outputs a value of $S$, and all values of $S$ are mapped. Consider the
procedure $\mathbb{P}'$ s.t. given an input $(\vec{x}, \vec{\alpha}) \in S$ it
\textit{a.} computes $\mathbb{P}$ with input  $x = 0, 1, \ldots$ until
$\mathbb{P}$ maps to $(\vec{x}, \vec{\alpha})$ and \textit{b.} then returns $x$.
Evidently $\mathbb{P}'$ computes the inverse of the function computed by
$\mathbb{P}$. Observe that $\mathbb{P}'$ will only halt if $(\vec{x},
\vec{\alpha}) \in S$. Then $S$ is the domain of a $\Sigma$-effectively
computable function.

$(\Leftarrow)$ Assume $S$ is the domain of a $\Sigma$-computable function. Let 
$(\vec{w}, \vec{\beta})$ an arbitrary element of $S$. Consider a procedure
$\mathbb{P}$ which does the following with an input $x \in \omega$.

\begin{quote}
    \textit{(1)} Produce the enumeration of $\omega \times \omega^{n} \times
    \Sigma^{*m} $ given by $x$. This will produce a variable $(t, \vec{x},
    \vec{\alpha})$.

    \textit{(2)} Run $t$ steps of $\mathbb{P}_f$ with input $(\vec{x},
    \vec{\alpha}) $. If the program terminated, return $(\vec{x},
    \vec{\alpha})$. If not, return $(\vec{w}, \vec{\beta})$.
\end{quote}

Evidently, $\mathbb{P}$ enumerates $S$. $\blacksquare$

\end{quote}
\normalsize

\begin{theorem}
    Let $f : \mathcal{D}_f \subseteq \omega^{n} \times \Sigma^{*m} \mapsto \varphi$ with
    $\varphi$ either $\omega$ or $\Sigma^{*}$. Let $S \subseteq \mathcal{I}_f$.
    Then if $f$ is $\Sigma$-effectively computable and $S$ is
    $\Sigma$-effectively enumerable, $f^{-1}(S) = \left\{ (\vec{x},
    \vec{\alpha}) : f(\vec{x}, \vec{\alpha}) \in S \right\} $ is
    $\Sigma$-effectively enumerable .
\end{theorem}

The theorem states that the set of inputs which map to a region of a computable
function's range is enumerable if that region is enumerable.

\begin{theorem}
    If $f : \mathcal{D}_f \subseteq \omega^{n} \times \Sigma^{*m} \mapsto
    \varphi$ with $\varphi$ either $\omega$ or $\Sigma^{*}$, then if $S
    \subseteq \mathcal{D}_f$ is $\Sigma$-effectively enumerable, $f_{| S}$ is
    $\Sigma$-effectively computable.
\end{theorem}



\subsection{Prime numbers and enumerable sets}

Let $\Sigma \neq \emptyset$ be an alphabet with a total order $\leq$. Let $S
\subseteq \omega^{n} \times \Sigma^{*m}$ a $\Sigma$-mixed set of arbitrary
dimensions. Notice that for any $n$-tuple $(x_1, \ldots, x_n)$, with $x_i \in
\omega$, we can find a corresponding $\varphi \in \mathbb{N}$ s.t. 

$$
\varphi = 2^{x_1}3^{x_2} \ldots pr(n)^{x_n}
$$

In other words, $(x_1, \ldots, x_n)$ corresponds to the exponents of the $n$
prime factors of a unique natural number. At the same time, the $m$-tuple
$(\alpha_1, \ldots, \alpha_m)$ corresponds to a unique $\psi \in \mathbb{N}$
s.t. 

$$
\psi = 2^{y_1}3^{y_2}\ldots pr(m)^{y_m}
$$

where $\alpha_j = *^{\leq}(y_j)$. In other words, $(\alpha_1, \ldots, \alpha_m)$
corresponds to a unique natural number whose $m$ prime factors have exponents
given by the position of each word in the language.

Both of these relations come from the uniqueness of prime factorizations.
They provide a way to enumerate $\Sigma$-mixed sets. In
particular, if $S$ is $\Sigma$-total we enumerate it mapping each $x \in \omega$
to $\big((x)_1, \ldots, (x)_n, *^{\leq}((x)_{n+1}), *^{\leq}((x)_m)\big)$. If
$S$ is not $\Sigma$-total, then one can still enumerate it assuming that it is
$\Sigma$-computable. Indeed, one maps $x$ to the corresponding $(n+m)$-tuple
described above if the tuple is in $S$, and leaves the procedure undefined (or
without halt) otherwise. This can be expressed as follows:

Because $\Sigma$-total sets are enumerable (as pointed out above), any
$\Sigma$-mixed set that is $\Sigma$-computable is enumerable (via restriction
of the $\Sigma$-total enumeration).

\begin{theorem}
    If $S \subseteq \omega^{n} \times \Sigma^{*m} $ is $\Sigma$-effectively
    computable, then it is $\Sigma$-effectively enumerable.
\end{theorem}

\small
\begin{quote}

\begin{problem}
    Prove that $S = \{(x, @^x) : x \equiv 0 \mod 2\}$ is $\{@\}$-effectively
    enumerable.
\end{problem}

$S$ is not $\Sigma$-total. $\therefore $ We require that it be
$\Sigma$-effectively computable. It is easy to see that
it is: Simply make a procedure that checks if $x$ is even, and that counts the
number of $@$s. Let $\mathbb{P}_\text{is in $S$}$ denote the procedure which decides the belonging of
$(x, \alpha)$ to $S$. 

It is also trivial to observe that $*^{\leq}$ is $\Sigma$-effectively
computable under any order of $\Sigma$, since the function is pretty much
algorithmic in nature. Let $\mathbb{P}_{\text{num to word}}$ denote the
procedure which given an input $x \in  \omega$ computes $*^{\leq}(x)$. Then we
define $\mathbb{P}$ the following procedure which takes an input $x \in
\omega$:

\footnotesize 
\begin{quote}
    \textit{(0)} Let $x_1$ be the number of times $2$ divides $x$ (this is, let
    it be the exponent of the first prime factor in the decomposition of $x$).
    Let $x_2$ be the number of times $3$ divides $x_1$ (the second prime in the
    decomposition of $x$).

    \textit{(1)} Use $\mathbb{P}_{\text{num to word}}$ to compute $*^{\leq}(x_2)$
    and store it in $\alpha$. 

    \textit{(3)} Use $\mathbb{P}_{\text{is in $S$}}$ to determine if $(x_0,
    \alpha) \in  S$. If it is, output $(x_0, \alpha)$. If it is not, go to step
    three.
\end{quote}
\small

\textit{Example.} Consider $\mathbb{P}(6)$. In \textit{(0)} this maps $x_1 = 1,
x_2 = 1$. Since the first word in $\Sigma$ is $@$, $6 \mapsto (1, @)$, which is
not in $S$. $\mathbb{P}$ will not halt.

Consider the tuple $(2, @@@@)$. We know there exists some $x \in \omega$ s.t.
$\mathbb{P}(x) = (2, @@@@)$ (I use math notation loosely here). Since $@@@@$ is
the fourth word in $\Sigma$, $x$ is s.t.
 $x = \langle 2, 4, (x)_3, (x)_4, \ldots \ldots\rangle $. For example, $2^2 + 3^4 =
85$ or $2^2 + 3^4 + 5^{17} = 762939453210$ will satisfy this.


\begin{problem}
    Prove the following statement: If $S \subseteq \omega$ and $f : S \mapsto
    \omega$ is $\Sigma$-effectively computable, then 
    
    \begin{align*}
        A = \left\{ x \in  S : x \text{ is even } \land x / 2 \in S \land f(x) = f(x
        / 2) \right\} 
    \end{align*}

    is $\Sigma$-effectively enumerable.
\end{problem}

Assume $f$ is $\Sigma$-effectively computable.  $\therefore S$ is
$\Sigma$-effectively enumerable. 

Let $\mathbb{P}_S$ be the procedure that enumerates $S$. Let $\mathbb{P}_f$
denote the procedure which computes $f$, $w \in S$ fixed and arbitrary, and $\mathbb{P}$ with input $x \in
\omega$ the following
procedure: 

\begin{quote}

    \textit{(0)} If $x = 0$ return $w$ and finish. 

    \textit{(1)} Use $\mathbb{P}_S$ twice, with inputs $(x)_1, (x)_2$
    respectively, to produce elements $s_1, s_2 \in S$. 

    \textit{(2)} Check if $s_1$ is even (this is trivially effectively
    computable). If it isn't, return $w$ and finish. 

    \textit{(3)} Check if $s_2 = s_1 / 2 $. If it isn't, return $w$ and finish.

    \textit{(4)} Use $\mathbb{P}_f$ to compute $f(s_1), f(s_2)$ and compare
    these values. If they are not equal, return $w$ and finish. 

    \textit{(5)} Return $s_1$.
\end{quote}

Evidently, $\mathbb{P}$ enumerates $A$.


\end{quote}
\normalsize



\pagebreak
\section{Turing}

From now on, we will attempt formalizations of three so far informal concepts: 

\begin{itemize}
    \item $\Sigma$-effectively computable functions
    \item $\Sigma$-effectively computable sets
    \item $\Sigma$-effectively enumerable sets
\end{itemize}

The first formalization is given by Turing.

\subsection{Turing machine}

A Turing machine is a $7$-uple $M = \left( Q, \Sigma, \Gamma, \delta, q_0, B, F
\right) $ where

\begin{itemize}
    \item $Q$ is a set of states 
    \item $\Gamma \supset \Sigma$ is an alphabet
    \item $\Sigma$ is the input alphabet
    \item $B \in \Gamma - \Sigma$ is a blank symbol 
    \item $\delta : Q \times \Gamma \mapsto \mathcal{P} \left( Q \times \Gamma \times \left\{
        L, R, K\right\}  \right) $ 
    \item $q_0 \in Q$ is the initial state 
    \item $F \subseteq Q$ is the set of final states
\end{itemize}


\small
\begin{quote}

\begin{problem}
    If $M$ a Turing machine then $\delta$ is a $\Sigma$-mixed function.
\end{problem}

A function is said to be a $\Sigma$-mixed function if $\mathcal{D}_f \subseteq
\omega^n \times \Sigma^{*m}$ for some $n, m \geq 0$ and $\mathcal{I}_f \subseteq
\omega$ or $\mathcal{I}_f \subseteq \Sigma^{*}$. The $\delta$ function satisfies
neither of these properties; its domain is a set of states $Q \times \Gamma \not\subseteq
\Sigma^{*m}$ and its image is a set of sets.

\begin{problem}
    If $M$ a Turing machine, $\mathcal{D}_{\delta}$ is a $\Sigma$-mixed set.
\end{problem}

A set $S$ is said to be $\Sigma$-mixed iff $S \subseteq \omega^n \times
\Sigma^{*m}$ for some $n, m \geq 0$. We have already mentioned that
$\mathcal{D}_\delta = Q \times \Gamma \not\subseteq \omega^n \times \Sigma^{*m}$ for any $n,
m$. Then $\mathcal{D}_\delta$ is not $\Sigma$-mixed.

\begin{problem}
    If $M$ a Turing machine, then $\mathcal{I}_{\delta}$ is $\Sigma$-mixed.
\end{problem}

False again.

\end{quote}
\normalsize


\subsection{Deterministic Turing machine}

A Turing machine is said to be deterministic iff $|\delta(p, \sigma)| \leq 1$
for all $p \in Q, \sigma \in \Gamma$. 

\subsection{Instantaneous descriptions}

An instantaneous description is a word of the form $\alpha q \beta $ where
$\alpha, \beta \in \Gamma^{*}, [\beta]_{|\beta |} \neq B$ and $q \in Q$. If the
instantaneous description is $\alpha_1 \alpha_2 \ldots \alpha_n q \beta_1
\beta_2 \ldots \beta_m B B B \ldots$, we read: \textit{The Turing
machine is in state $q$ and it is reading $\beta_1$}. We use $\mathbb{D}$ to
denote the set of instantaneous descriptions. We define 

\begin{align*}
    St : \mathbb{D} &\mapsto  Q \\ 
    d &\mapsto \text{Only symbol of $Q$ that is in $d$}
\end{align*}


\small
\begin{quote}

\begin{problem}
    Let $d \in \mathbb{D}$ an instantaneous description. Then $Ti(d)$ is a
    triple.
\end{problem}

False: $d$ is not a triple but a single element of $(\Gamma \cup Q)^{*}$.

\begin{problem}
    If $d \in \mathbb{D}$ then $St(d) = d \cap Q$
\end{problem}

False. The operation $d \cap Q$ makes no sense, insofar as $d$ is a symbol. It
would be correct to say $St(d) = \{d_1, d_2, \ldots, d_m\} \cap Q$ where $d_i$ are
the characters in the word $d$.


\end{quote}
\normalsize

\subsection{State transitions}

\small
\begin{quote}
\textit{Preliminary def. }

Given $\alpha \in (\Gamma \cup Q)^*$ we define 

\begin{align*}
    \left\lfloor \varepsilon \right\rfloor  &= \varepsilon \\ 
    \left\lfloor \alpha \sigma  \right\rfloor  &= \alpha \sigma \text{   if } \sigma \neq B \\ 
    \left\lfloor \alpha B \right\rfloor &= \left\lfloor  \alpha \right\rfloor
\end{align*}

Thus, $[[ \alpha ]]$ removes the trailing blank symbols of $\alpha$ (if any).
\end{quote}
\normalsize 

Given $d_1, d_2 \in \mathbb{D}$ with $d_1 = \alpha p \beta $, we say $d_1 \vdash
d_2$ if, given $\alpha \in \Gamma, \alpha, \beta \in  \Gamma^*, p, q \in Q$, one
of the following three cases hold.

~

\textit{(Case 1)} $\alpha \neq \varepsilon$, and

\begin{align*}
    \delta \left( p, \left[ \beta B \right]_1  \right) \ni (q, \sigma, L)
\end{align*}

and 
$$d_2 = \left\lfloor \alpha {}^{\curvearrowleft} q [\alpha]_{|\alpha|} \sigma
{}^{\curvearrowright} \beta  \right\rfloor$$

\small 
\begin{quote}
    \textit{Interpretation.} The Turing machine at state $p$ will write $\sigma$
    at its current position, transition to state $q$, and move to the left. 

    \textit{Example.} Let $\Sigma = \{ @, \#\}$. Assuming $\delta (p) = \{ (q,
    \#, L) \}$, then the following is an example of
    \textit{Case 1}.
    
    \begin{align*}
        &@ ~ \# ~ @ ~ p ~ @ ~ @ ~ @ ~ B ~ B ~ B \vdash  @ ~ \# ~q ~ @ ~ \# ~ @ ~ @ ~ B ~ B
        ~ \ldots
    \end{align*}
\end{quote}
\normalsize 

~ 

\textit{(Case 2)} 

\begin{align*}
    \delta \left( p, \left[ \beta B \right]_1  \right) \ni (q, \sigma, R)
\end{align*}

and 

$$d_2 = \alpha \sigma q {}^{\curvearrowright} \beta $$

\small 
\begin{quote}
    \textit{Interpretation.} The Turing machine at state $p$ will write $\sigma$
    at its current position, transition to state $q$, and move to the left. 

    \textit{Example.} Let $\Sigma = \{ @, \#\}$. Assuming $\delta (p) = \{ (q,
    \#, R) \}$, then the following is an example of
    \textit{Case 2}.
    
    \begin{align*}
        &@ ~ \# ~ @ ~ p ~ @ ~ @ ~ @ ~ B ~ B ~ B \vdash  @ ~ \# ~@ ~ \# ~ q ~ @ ~
        @~ B ~ B
        ~ \ldots
    \end{align*}
\end{quote}
\normalsize 


\textit{(Case 3)} 

\begin{align*}
    \delta \left( p, \left[ \beta B \right]_1  \right) \ni (q, \sigma, K)
\end{align*}

and 

$$d_2 = \left\lfloor \alpha q \sigma {}^{\curvearrowright} \beta  \right\rfloor $$

\small 
\begin{quote}
    \textit{Interpretation.} The Turing machine at state $p$ will write $\sigma$
    at its current position, transition to state $q$, and stay at the same
    position.

    \textit{Example.} Let $\Sigma = \{ @, \#\}$. Assuming $\delta (p) = \{ (q,
    \#, K) \}$, then the following is an example of
    \textit{Case 2}.
    
    \begin{align*}
        &@ ~ \# ~ @ ~ p ~ @ ~ @ ~ @ ~ B ~ B ~ B \vdash  @ ~ \# ~@ ~ q ~ \# ~  @ ~
        @~ B ~ B
        ~ \ldots
    \end{align*}
\end{quote}
\normalsize 

We say $d \vdash^n d'$ if there are $d_1, \ldots, d_{n+1}$ s.t. $d = d_1, d' =
d_{n+1}$, and $d_i \vdash d_{i + 1}$ for all $i = 1, \ldots, n$. Observe that $d
\vdash^0 d'$ if $d = d'$. Finally, we denote $d \vdash^{*} d'$ iff $(\exists n
\in \omega) ~ d \vdash^n d'$.


\small
\begin{quote}

\begin{problem}
    Determine true or false for the following propositions.
\end{problem}

\textit{(1) $d \vdash d$ for all $d \in \mathbb{D}$}. The proposition is false.
It is trivial to find a counterexample.

\textit{(2) If $\alpha p \beta  \not\vdash  d$ for every $d \in \mathbb{D}$,
then $\delta(p, [\beta B]_1) = \emptyset$}. Assume $\alpha p \beta \not\vdash d$
for every $d \in \mathbb{D}$. Assume $\delta(p, [\beta B]_1) \neq \emptyset$.
Then there must be some $\{(q, \sigma, D)\}$ with $D \in \left\{ L, R, K
\right\} $ that corresponds to this evaluation of $\delta$. But then there would
exist some $d$, given by the case division above and depending on the value of
$D$, s.t. $\alpha p \beta \vdash d$. But this is a contradiction. The statement
is true.

\textit{(3) If $(p, \alpha, L) \in \delta(p, a)$ then $pa \not\vdash d$ for all
$d \in \mathbb{D}$}. This is correct. Remember that for a transition to the left
to be defined we require that a substring $\alpha \neq \varepsilon$ precede the
Machine's head. (See \textit{Case 1}, requirement $\alpha \neq \varepsilon$.) But
here $d_1 = pa$ has an initial segment $\varepsilon$ preceding $p$. Then $pa \neq
d$ for any $d$. The statement is true.

\textit{(4)} \textit{  Given $d_1, d_2 \in \mathbb{D}$, if $d_1 \vdash d_2$ then
$|d_1| \leq |d_2| + 1$. } It makes no sense to say $|d_1| \leq |d_2| + 1$
insofar as an instantaneous description contains infinitely many symbols $B$ at
the end. So the statement, as it is phrased, is false. However, consider the
alternative postulate: $d_1 \vdash d_2 \Rightarrow |\left\lfloor d_1
\right\rfloor| \leq | \left\lfloor d_2 \right\rfloor | + 1$. Two instantaneous
description over the same machine always have the same number of symbols. So $ |
\left\lfloor d_1 \right\rfloor| = | \left\lfloor d_2 \right\rfloor | $, which
makes the statement trivially true.

\begin{problem}
    Prove that $M$ is deterministic iff for each $d \in \mathbb{D}$ there is
    \textit{at most} one $d' \in \mathbb{D}$ s.t. $d \vdash d'$.
\end{problem}

( $\Rightarrow$ ) Assume $M$ is deterministic. Then for any $d \in \mathbb{D}$
of the form $\alpha q \beta B B \ldots$, we have either $\delta(q) = \left\{
(q', \sigma, D) \right\} $ or $\delta(q) = \emptyset$. If $\delta(q) =
\emptyset$, then (by definition of $\vdash$) there is no instantaneous description $d'$ s.t. $d \vdash d'$.
If $\delta(q) = \left\{ (q', \sigma, D) \right\} $, then two cases are possible.
\textit{(1)} $d$ holds the assumptions sustaining the case definition of
$\vdash$, in which case the transition is uniquely determined by $(q',
\sigma, D)$. \textit{(2)} $d$ does not hold the assumptions sustaining the
case definition of $\vdash$ (e.g. $D = L, \alpha = \varepsilon$), in which case
there is by definition no $d'$ s.t. $d \vdash d'$

($\Leftarrow$) This does not hold!! Assume that, for all $d \in \mathbb{D}$,
there is at most one $d'$ s.t. $d \vdash d'$. 
 Consider the case where there is no $d'$ s.t. $d \vdash d'$. In the case where
 $\alpha = \varvarepsilon$ and

$$
\delta(q) = \{ (q', \sigma, L), (q'', \sigma', L) \}
$$

the machine is non-deterministic without violating the assumption. In other
words, that $d \vdash d'$ for at most one $d'$ does not imply that the machine
is deterministic.

\end{quote}
\normalsize


\subsection{Halting and languages}

Given $d \in \mathbb{D}$, we say $M$ halts starting from $d$ if there is some
$d' \in \mathbb{D}$ s.t. 

\begin{align*}
    &d \vdash^* d' \\ 
    &d' \not\vdash d'' \text{ for all } d'' \in \mathbb{D}
\end{align*}

We say a word $w \in \Sigma^{*}$ is accepted by a Turing machine $M$ \textit{by reach of final
state} if

\begin{align*}
    \exists d \in \mathbb{D} : \left\lfloor q_0 B w \right\rfloor \vdash^* d \land ~ St(d) \in F
\end{align*}

The language accepted by a Turing machine is 

\begin{align*}
    \mathcal{L}(M) = \left\{w \in \Sigma^{*}:  w \text{ is accepted by reach of final state } \right\} 
\end{align*}


\small
\begin{quote}

\begin{problem}
    Let $\Sigma = \left\{ a, b \right\} $. Find a Turing machine $M$ that
    accepts the language $ \left\{ w \in \Sigma^{*} : |\omega|_a = 2|\omega|_b
    \right\} $
\end{problem}

As examples, here are some words accepted by the language: $\varepsilon, aab, baa,
ababaa, \ldots$ Our machine will operate in the following manner.

\textit{(1)} It will parse the string looking for a $b$; if a $b$ is found, it
replaces it with $y$, sets the head of the machine to the beginning, and
proceeds to parse for two $a$s and replace them with $x$s. This gives 

\begin{align*}
    \delta(q_0, \sigma) &= \begin{cases}
        \left\{ \left( q_1, y, L \right)  \right\} & \sigma = b\\
        \left\{ \left( q_0, \sigma, R \right)  \right\} & \sigma = a\\
        \left\{ \left( q_9, \sigma, L \right)  \right\} & \sigma = B
    \end{cases} \\
    \delta(q_1, \sigma) &= \begin{cases}
        \left\{ \left( q_1, \sigma, L \right)  \right\} & \sigma \neq \varepsilon
        \\ 
        \{ (q_2, \varepsilon, R) \} & \sigma = \varepsilon
    \end{cases}
\end{align*}

where $q_1$ resets the machine's head to the initial position. Now 

\begin{align*}
    \delta(q_2, \sigma) &= \begin{cases}
        \left\{ (q_3, x, R) \right\}  & \sigma = a \\ 
        \left\{ (q_2, \sigma, R) \right\}  & \sigma \neq a \\ 
    \end{cases}\\
    \delta(q_3, \sigma) &= \begin{cases}
        \left\{ (q_4, x, R) \right\}  & \sigma = a \\ 
        \left\{ (q_3, \sigma, R) \right\}  & \sigma \neq a \\ 
    \end{cases}
\end{align*}

The state $q_4$ occurs after two $a$s have been found to correspond to a single
$b$. Thus, we must return to $q_0$ with the machine head reset to its initial
position. 

\begin{align*}
    \delta(q_4, \sigma) = \begin{cases}
        \left\{ \left( q_4, \sigma, L \right)  \right\} & \sigma \neq \varepsilon
        \\
        \left\{ \left( q_0, \sigma, R \right)  \right\} & \sigma = \varepsilon 
    \end{cases}
\end{align*}

The only undefined state is $q_9$. This is the state reached after, in state
$q_0$, the string is parsed but no $b$ is found. If there is some $a$ left in
the string, then the word must not be accepted; but if no $a$ exists, the word
must be accepted. Thus, $q_9$ can parse from right to left looking for $a$s; if
$\varepsilon$ is reached without $a$s on the way, it should map to a final state.
If some $a$ is found, it should never halt.

\begin{align*}
    \delta(q_9, \sigma) = \begin{cases}
        \left[ \left( q_9, \sigma, L \right)   \right] & \sigma \neq\in \{a,
        \varepsilon\} \\
        \left[ \left( q_9, \sigma, K \right)   \right] & \sigma = a \\ 
        \left[ \left( q_\mathcal{F}, \sigma, K \right)   \right] & \sigma = \varepsilon \\ 
    \end{cases}
\end{align*}

where $q_{\mathcal{F}} \in F$ is the only final state. Of course, $\Gamma = \{a,
b, x, y, B\}, Q = \{ q_0, q_1, q_2, q_3, q_4, q_9, q_{\mathcal{F}}\}$.

\end{quote}
\normalsize

We say a word $w \in \Sigma^{*}$ is accepted by detention (or by a halt) if $M$
halts when starting from $ \left\lfloor q_0 B \omegam \right\rfloor  $. We
denote 

\begin{align*}
    \mathcal{H}(M) = \left\{ \omegam \in \Sigma^{*}: \omegam \text{ is accepted
    by detention} \right\} 
\end{align*}

\begin{theorem}
    Let $L \subseteq \Sigma^{*}$. Then the following statements are equivalent: 

    \textit{(1)} There is a Turing machine $M$ s.t. $L = L(M)$. 

    \textit{(2)} There is a Turing machine $M$ s.t. $L = \mathcal{H}(M)$.
\end{theorem}

\subsection{$\Sigma$-Turing computable functions}

To represent numbers on the Turing tape, we use the $i$ letter. Thus, we extend
the definition of a Turing machine ensuring that $i \in  \Gamma - \left( \{B\}
\cup \Sigma \right) $ is a symbol.

Let $f : \mathcal{D}_f \subseteq \omega^{n} \times \Sigma^{*m} \mapsto
\Sigma^{*}$ a $\Sigma$-mixed function. We say $f$ is $\Sigma$-Turing computable
if there is a deterministic Turing machine $M$ s.t. 

\begin{itemize}
    \item If $(\vec{x}, \vec{\alpha}) \in \mathcal{D}_f$, then there is a state
        $p \in Q$ s.t. 
        \begin{align*}
            \left\lfloor q_0 ~ B ~ i^{x_1} ~ B ~ \ldots ~ i^{x_n} ~ B ~ \alpha_1
            ~ B ~ \ldots ~ B ~ \alpha_m\right\rfloor \vdash^* \left\lfloor pB
            f(\vec{x}, \vec{\alpha}) \right\rfloor
        \end{align*} 

    \item If $(\vec{x}, \vec{\alpha}) \in \omega^{n} \times \Sigma^{*m} -
        \mathcal{D}_f$, then the machine does not halt starting from  
        \begin{align*}
            \left\lfloor q_0 ~ B ~ i^{x_1} ~ B ~ \ldots ~ i^{x_n} ~ B ~ \alpha_1
            ~ B ~ \ldots ~ B ~ \alpha_m\right\rfloor 
        \end{align*}
\end{itemize}

When $f \mapsto \omega$, we analogously say a Turing machine computes $f$ iff

\begin{itemize}
    \item If $(\vec{x}, \vec{\alpha}) \in \mathcal{D}_f$, then there is a state
        $p \in Q$ s.t. 
        \begin{align*}
            \left\lfloor q_0 ~ B ~ i^{x_1} ~ B ~ \ldots ~ i^{x_n} ~ B ~ \alpha_1
            ~ B ~ \ldots ~ B ~ \alpha_m\right\rfloor \vdash^* \left\lfloor pB
            i^{f(\vec{x}, \vec{\alpha})} \right\rfloor
        \end{align*} 

    \item If $(\vec{x}, \vec{\alpha}) \in \omega^{n} \times \Sigma^{*m} -
        \mathcal{D}_f$, then the machine does not halt starting from  
        \begin{align*}
            \left\lfloor q_0 ~ B ~ i^{x_1} ~ B ~ \ldots ~ i^{x_n} ~ B ~ \alpha_1
            ~ B ~ \ldots ~ B ~ \alpha_m\right\rfloor 
        \end{align*}
\end{itemize}

If $M$ and $f$ satisfy the properties above, we say $f$ is computed by $M$.

\begin{theorem}
    If $f : \mathcal{D}_f \subseteq \omega^{n} \times \Sigma^{*m} \mapsto I \in
    \{\omega, \Sigma^{*}\}$ is computed by a Turing machine $M$, then $f$ is $\Sigma$-effectively
    computable.
\end{theorem}


\small
\begin{quote}

\begin{problem}
    Determine if the following statements are true or false.
\end{problem}

\textit{(1) If $M$ a deterministic turing machine and $M$ computes $f$, then
$\mathcal{L}(M) = \mathcal{D}_f$}. 

Since $M$ computes $f$, $M$ halts for any
$(\vec{x}, \vec{\alpha}) \in \mathcal{D}_f$ and does not halt for any $(\vec{x},
\vec{\alpha}) \not\in \mathcal{D}_f$. Then, by definition, $\mathcal{H}(M) =
\mathcal{D}_f$. This does not imply $\mathcal{L}(M) = \mathcal{D}_f$. However,
it does imply that there necessarily exists a Turing machine $M'$ s.t.
$\mathcal{L}(M') = \mathcal{D}_f$.

\textit{(2)}  \textit{ If $f, g$ are two functions and $M$ is a Turing machine that
computes $f$ and $g$, then $f = g$.} Assume the premise holds. Then
$\mathcal{H}(M) = \mathcal{D}_f = \mathcal{D}_g := \mathcal{D}$. Furthermore, for any
$(\vec{x}, \vec{\alpha}) \in \mathcal{D}$, the Turing machine halts with an
instantaneous description representing $f (\vec{x}, \vec{\alpha}) $. But since
it computes $g$, the instantaneous description also represents $g (\vec{x},
\vec{\alpha}) $. This implies $f (\vec{x}, \vec{\alpha}) = g (\vec{x},
\vec{\alpha}) $. Then $f = g$. The statement is true.

\textit{(3) Let $M$ a Turing machine and assume $M$ computes $f$ with $f$ a
$\Sigma$-total function. Then $M$ halts from $d$ for whichever $d \in
\mathbb{D}$}. It is true that, since $f$ is $\Sigma$-total, for any $(\vec{x},
\vec{\alpha}) \in \omega^{n} \times \Sigma^{*m} $, $f (\vec{x}, \vec{\alpha}) $
is defined. This does imply that every $d$ of the form $\left\lfloor q_0 i^{x_1}\ldots i^{x_n} \alpha_1
\ldots \alpha_m \right\rfloor$ is accepted (I skipped the possibly infinite $B$
symbols in the description). However, there is no restriction in $\mathbb{D}$ as
to the number of unit or alphabetic symbols which an arbitrary $d \in
\mathbb{D}$ may contain. Thus,  

\begin{align*}
    \mathbb{D}' \subseteq \mathbb{D} = \left\{ d \in \mathbb{D} : \left\lfloor d
    \right\rfloor = \left\lfloor q_0 i^{x_1} \ldots i^{x_k} \alpha_1 \ldots
\alpha_l \right\rfloor : k \neq n \lor l \not\in m  \right\} 
\end{align*}

satisfies $D' \not\subseteq \mathcal{H}(M)$.


\end{quote}
\normalsize




\pagebreak
\section{Godel}

\begin{definition}
    A set $S_1\times  \ldots  \times  S_n \times L_1 \times  \ldots \times  L_m$ is
    rectangular if $S_i \subseteq \omega, L_i \subseteq \Sigma^{*}$ for all $i$.
\end{definition}

\begin{lemma}
    $S$ is rectangular if and only if $(\overrightarrow{x},
    \overrightarrow{\alpha}) \in S \land (\overrightarrow{y},
    \overrightarrow{\beta}) \in S$ implies $(\overrightarrow{x},
    \overrightarrow{\beta}) \in S$.
\end{lemma}

\textit{Example}. The set $\{(0, \#\#), (1, \%\%\%)\}$ is not rectangular ($(1,
\#\#), (0, \%\%\%)$ are not in $S$.) Observe how this set cannot be expressed as
a product of subsets of $\omega$ and $\Sigma$. Thus, the concept of
\textit{rectangular set} is equivalent to \textit{a set formed via Cartesian
product}.

~

\textit{Notation.} If $f : \omega_1 \times \ldots \times \omega_n \times
\alpha_1 \times \alpha_m \to \Lambda$ we write $f \sim (n, m, \Lambda)$, and
read $f$ is of type $n, m$ to $\Lambda$.

\textit{Notation.} If $f_1, \ldots, f_n$ $\Sigma$-mixed functions, then 

\begin{align*}
    \left[ f_1, \ldots, f_2 \right](\overrightarrow{x}, \overrightarrow{\alpha})
    = \left( f_1(\overrightarrow{x}, \overrightarrow{\alpha}), \ldots,
    f_n(\overrightarrow{x}, \overrightarrow{\alpha}) \right) 
\end{align*}


\subsection{Primitive recursion} 

Let $R$ a $\Sigma$-mixed function s.t. $R \sim (n, m, \varphi)$, where $\varphi
= \omega$ or $\varphi = \Sigma^{*}$. Primitive recursion consists in recursively
defining $R$ with two primitive functions $f$, which gives the base case, and
$g$, which gives the recursive step. The recursion is done over $\omega$,
associating $R(t, \vec{x}, \vec{\alpha})$ with $R(t - 1, \vec{x},
\vec{\alpha})$, or over $\Sigma^{*}$, associating $R(\vec{x}, \vec{\alpha},
\alpha a)$ with $R(\vec{x}, \vec{\alpha}, \alpha)$. Since the computation of $R$
may depend on the element which the
recursion dismisses ($t$ in the numeric case, $a$ in the alphabetic case), $g$
incorporates this value into its arguments. Thus, we have that: 

\begin{itemize}
    \item If $\varphi = \omega$ 
        \begin{itemize}
            \item If the recursion is over $\omega$, $f \sim (n - 1, m, \omega),
                g \sim (n + 2, m, \omega)$
            \item If the recursion is over $\Sigma^{*}$, $f \sim (n, m - 1,
                \omega), g \sim (n + 1, m + 1, \omega)$.
        \end{itemize}
    \item If $\varphi = \Sigma^{*}$ 
        \begin{itemize}
            \item If the recursion is over $\omega$, $f \sim (n - 1, m, \Sigma^{*}),
                g \sim (n + 1, m + 1, \Sigma^{*})$
            \item If the recursion is over $\Sigma^{*}$, $f \sim (n, m - 1,
                \Sigma^{*}), g \sim (n, m + 2, \Sigma^{*})$.
        \end{itemize}
\end{itemize}

We say $f, g$ construct $R$ via primitive recursion and we denote $R$ as $R(f,
g)$.

\subsection{Numeric to numeric primitive recursion}

Let $R \sim (n, m, \#)$. Then functions $f \sim (n - 1, m, \#), g \sim (n + 1,
m, \#)$ recursively define $R$ if and only if 

\begin{align*}
\begin{cases}
    R(0, \overrightarrow{x}, \overrightarrow{\alpha}) &= f(
        \overrightarrow{x}, \overrightarrow{\alpha}) \\
    R(t + 1, \overrightarrow{x}, \overrightarrow{\alpha}) &= g \left( R(t,
        \overrightarrow{x}, \overrightarrow{\alpha}), t, \overrightarrow{x},
    \overrightarrow{\alpha} \right)
\end{cases}
\end{align*}

We use the notation $R(f, g)$ to say $R$ is defined by primitive recursion by
$f$ and $g$.



\small
\begin{quote}

\begin{problem}
    Find functions that recursively define $R = \lambda t \left[ 2^t \right] $
\end{problem}

Since $R ~ (1, 0, \#)$ we know $f \sim (0, 0, \#)$ is a constant function and $g
\sim (2, 0, \#)$. Since $R(0) = 1$ we know $f = C_{1}^{0, 0}$. Observe that $R(t
+ 1) = R(t) \times 2$. Thus we may let $g = \lambda x [2 \cdot x] \circ
p_{1}^{2, 0}$. 

\textit{Example.} $R(2) = \lambda x[2x] \circ p_1^{2, 0} \left( R(1), 2 \right)
= 2 \times R(1) = 2 \times \left( 2 \times R(0) \right) = 2 \times 2 \times 1 =
4$.

\begin{problem}
    Define $R(t) = \lambda tx_1\left[ x_1^t \right] $ recursively.
\end{problem}

Since $R \sim (2, 0, \#)$ we know $f \sim (1, 0, \#)$ and $g \sim (3, 0, \#)$.
Now, $R(0, x_1) = 1 \implies f = C_{1}^{1, 0}$. Since $R(t + 1, x_1) = R(t, x_1)
\cdot x_1$  we observe that $g = \lambda xy[xy] \circ \left[ p_1^{3, 0},
p_{3}^{3, 0} \right] $. Since each $p_{k}^{3, 0} \sim (3, 0, \#)$ we have that
$g$ is of the desired type.

\begin{problem}
    Is it true that $R(\lambda xy[0], p_2^{4, 0}) = p_1^{3, 0}$?
\end{problem}

$R \sim (2, 0, \#)$; $f \sim (2, 0, \#)$. So $f$ cannot be a primitive
constructor of $R$.

\begin{problem}
    Determine true or false: If $f : \omega^2 \to \omega$ and $g : \omega^4 \to
    \omega$, then for each $(x, y) \in \omega^2$ we have

    \begin{align*}
        R(f, g)(2, x, y) = g \circ \left( g \circ \left[ f \circ \left[ p_2^{3,
        0}, p_2^{3, 0} \right], p_1^{3, 0}, p_2^{3, 0}, p_3^{3, 0}  \right]
    \right) (0, x, y).
    \end{align*}
\end{problem}

Passing the arguments into the functions this results in 

\begin{align*}
    R(f, g)(2, x, y) &= g \circ \left( g \circ \left[ f(x, x) , 0, x, y
    \right]\right)  \\ 
                     &= g \circ \left( g \left( f(x, x), 0, x, y \right)
                     \right)
\end{align*}

But the expression makes no sense, since $\zeta = g(f(x, x), 0, x, y) \in
\omega$ is not a function and hence $g \circ \zeta$ is undefined.

\end{quote}
\normalsize

\subsection{Numeric to alphabet primitive recursion}


Let $R \sim (n, m, \Sigma)$. Then functions $f \sim (n - 1, m, \Sigma),  g \sim (n,
m + 1, \Sigma)$ recursively define $R$ if and only if 

\begin{align*}
    R(0, \overrightarrow{x}, \overrightarrow{\alpha}) &= f(\overrightarrow{x},
    \overrightarrow{\alpha}) \\ 
    R(t + 1, \overrightarrow{x}, \overrightarrow{\alpha}) &= g \left(t,
    \overrightarrow{x}, \overrightarrow{\alpha}, R(t, \overrightarrow{x},
\overrightarrow{\alpha})  \right) 
\end{align*}


\small
\begin{quote}

\begin{problem}
    Let $\Sigma = \{\%, @, ?\}$. Define $R = \lambda t x_1 [\% @ \% \% \% \%
    ?^{t}]$ via primitive recursion.
\end{problem}

Let $f = C_{\% @ \% \% \% \%}^{1, 0}$ and $g = d_{?}  \circ \left[ p_{3}^{2, 1}
\right] $. For example, $R(3, x_1) = 
d_? \circ \left[ R(2, x_1)
\right] = d_? \circ  \left[ d_? \circ R[1, x_1] \right] = d_? \circ \left[ d_?
\circ \left[ d_? \circ \left[ C_{\% @ \% \% \% \%}^{1, 0}  \right]  \right]
\right] = \% @ \% \% \% \% ? ? ? $.

\begin{problem}
    True or false: If $f, g$ are $\Sigma$-mixed s.t. $R(f, g) \sim (1 + n, m,
    *)$, then $f \sim (n, m, *)$ and $g \sim (n, m+1, *)$.
\end{problem}

False. The $g$ function must have the same number of numeric arguments than $R$.

\end{quote}
\normalsize


\subsection{Alphabet to numeric primitive recursion}

If $\Sigma$ an alphabet, then a $\Sigma$-indexed family of functions is a
function $\mathcal{G}$ s.t. $D_{\mathcal{G}} = \Sigma$ and for each $a \in
D_{\mathcal{G}}$ there is a function $\mathcal{G}(a)$. We write $\mathcal{G}_a$
instead of $\mathcal{G}(a)$.

If $R \sim (n, m, \omega)$ then $R$ can be recursively defined by $f \sim (n, m
- 1, \omega)$ an indexed
family $\mathcal{G}$ s.t. $\mathcal{G}_a \sim (n + 1, m, \omega)$ as follows: 

\begin{align*}
    \begin{cases}
        R(F, \mathcal{G})(\overrightarrow{x}, \overrightarrow{\alpha}, \varepsilon)
        = f(\overrightarrow{x}, \overrightarrow{\alpha}) \\ 
        R(f, \mathcal{G})(\overrightarrow{x}, \overrightarrow{a}, \alpha a) =
        \mathcal{G}_a \left( R(\overrightarrow{x}, \overrightarrow{\alpha},
        \alpha), \overrightarrow{x}, \overrightarrow{\alpha}, \alpha \right) 
    \end{cases}
\end{align*}


\small
\begin{quote}


\begin{problem}
    Let $\Sigma = \{\%, @, ?\}$. Find $f, \mathcal{G}$ s.t. $R = \lambda \alpha_1
    \alpha \left[ |\alpha_1| + |\alpha|_{@} \right] $.
\end{problem}

$R \sim (0, 2, \#)$. Since $R(\alpha_1, \varepsilon) = | \alpha_1|$ we let $f :=
\lambda \alpha = |\alpha|$. Now, $g \sim (1, 2, \#)$ is given by $g :=
\mathcal{G}$ where 

\begin{align*}
    &\mathcal{G} : \Sigma \to \{ Suc \circ p_1^{1, 2}, p_1^{1, 2}  \} \\ 
    &~ ~ ~ ~ ~ ~  \% = p_{2}^{1, 2}\\
    &~ ~ ~ ~ ~ ~  ? = p_{2}^{1, 2}\\
    &~ ~ ~ ~ ~ ~  @ = Suc \circ p_{2}^{1, 2}
\end{align*}

For example, $R(??, @\%?@) = \mathcal{G}_{@} \left( R(@\%?), ??, @ \right) = 1 +
R(??, @\%?) $. This boils down to $1 + R(??, @) = 1 + 1 + R(??, \varepsilon) = 2 +
|??| = 2$, the desired output.

\end{quote}
\normalsize


\subsection{Alphabet to alphabet primitive recursion}

If $R \sim (n, m, *)$ then $f \sim (n, m-1, *)$ and $\mathcal{G}$ a $\Sigma$-indexed
family, with $\mathcal{G}_a \sim (n, m+1, *)$ for all $a\in \Sigma$, define $R$
via primitive recursion if 

\begin{align*}
    \begin{cases}
        R(\overrightarrow{x}_n, \overrightarrow{\alpha}_{m-1}, \varepsilon) &=
        f(\overrightarrow{x}, \overrightarrow{\alpha}) \\ 
        R(\overrightarrow{x_n}, \overrightarrow{\alpha}_{m-1}, \alpha a)&= \mathcal{G}_a
        \left( \overrightarrow{x}, \overrightarrow{\alpha},
        \alpha, R(\overrightarrow{x}, \overrightarrow{\alpha}, \alpha) \right) 
    \end{cases}
\end{align*}

\begin{problem}
    Let $\Sigma = \{ @, ? \}$. Define $R = \lambda \alpha_1 \alpha [ \alpha_1
    \alpha ]$ recursively.
\end{problem}

Observe that $R \sim (0, 2, *)$. $R(\alpha_1, \varepsilon) = \alpha_1 \implies f :=
\lambda \alpha[\alpha]$. Now, we let $\mathcal{G}_{a} = d_a \circ p_{3}^{0, 3}$
for all $a \in \Sigma$, and the recursion is complete.

\textit{Example.} The evaluation for arbitrary inputs looks as follows:

\begin{align*}
    R(?@?, @?) &= d_? \left( R(?@?, @) \right)  \\ 
               &= d_? \left( d_@ \left( R(?@?, \varepsilon) \right)  \right)  \\ 
               &= d_? \left(  d_@ \left( ?@? \right)  \right)  \\ 
               &= d_? \left( ?@?@ \right) \\ 
               &= ?@?@?
\end{align*}

\subsection{The point of primitive recursion}

\begin{theorem}
    If $f, g$ are $\Sigma$-computable then $R(f, g)$ is too.
\end{theorem}

\subsection{The primitive recursive set}

Let $\Sigma$ a language. We define $PR_0^{\Sigma} = \left\{ Suc, Pred, C_0^{0,
0}, C_{\varepsilon}^{0, 0} \right\} \cup \left\{ d_a \right\} \cup \left\{ p_j^{n,
m} \right\}  $. Observe that every $\mathcal{F} \in PR_0^{\Sigma}$ is
$\Sigma$-computable. Then we define 

\begin{align*}
    PR_{k + 1} &= PR_{k}^{\Sigma} \cup \left\{ f \circ \left[ f_1\ldots f_r
    \right] : f \text{ and } f_i \in PR_{k}^{\Sigma} \cup  \right\} \cup \left\{
R(f, g) : f, g \in PR_{k}^{\Sigma}\right\} 
\end{align*}

In other words, $PR_{k}^{\Sigma}$ is the set of all functions that are either
compositions of functions in $PR_{k-1}^{\Sigma}$ or functions built via
primitive recursion by functions in $PR_{k-1}^{\Sigma}$. The total primitive
recursive set $PR^{\Sigma}$ is defined as $PR^{\Sigma} = \bigcup_{k \geq 0}
PR_{k}^{\Sigma}$.

\textit{Note.} Observe that when we include $R(f, g) : f, g \in
PR_{k}^{\Sigma}$, we also include the case where $g = \mathcal{G}$ an indexed
family of functions.

\textit{Observation} Due to the previous theorem, we know $\mathcal{F} \in PR
\Rightarrow \mathcal{F} $ is $\Sigma$-computable.

~ 

I provide a list of functions that are in $PR^{\Sigma}$ for any $\Sigma$.


\begin{itemize}
    \item Addition, multiplication and factorial 
    \item String concatenation and string length  
    \item All constant functions $C_k^{n, m}$ for any $k, n, m \in \omega$.
    \item Two-variable exponentiation: $\lambda xy\left[ x^y \right] $. 
    \item Two-variable string exponentiation: $\lambda x\alpha\left[ \alpha^x
        \right] $.
\end{itemize}

With $x - y := \max(x - y, 0)$ the list may continue: 

\begin{itemize}
    \item The maximum of two numeric variables 
    \item The predicates $x = y, x \leq y, \alpha = \beta$.
    \item The predicate $x$ is even. 
    \item The predicate $x = |\alpha|$. 
    \item The predicate $\alpha^x = \beta$.
\end{itemize}

\subsection{Predicates}

The $\lor, \land$ operators are defined only for predicates of the same type. In
other words, $P \circ Q$, where $\circ \in \{\land, \lor\}$, is defined only if
$P \sim (n, m, \#) \land Q \sim (n, m, \#)$. If $P, Q$ are $\Sigma$-p.r. then $P
\circ Q$ and $\neg P$ also are. Furthermore, $P, Q$ must have the same domains.

\subsection{Primitive recursive sets}

A $\Sigma$-mixed $S \sim (n, m)$ set is primitive recursive if and only if its
characteristic function $\chi_S^{\omega^n \times \Sigma^{m*}}$ is p.r. Recall
that $\chi_S^{n, m} = \lambda
\overrightarrow{x}\overrightarrow{\alpha}[(\overrightarrow{x},
\overrightarrow{\alpha}) \in S]$.

If $S_1, S_2$ are $\Sigma$-p.r. then their union, intersection and difference
are. The proof follows from the fact that 

\begin{align*}
    \chi_{S_1 \cup S_2} &= \left( \chi_{S_1} \lor \chi_{S_2} \right) \\ 
    \chi_{S_1 \cap S_2} &= \left( \chi_{S_1} \land \chi_{S_2} \right) \\ 
    \chi_{S_1 - S_2} &= \lambda xy[x - y] \circ \left[ \chi_{S_1}, \chi_{S_2} \right] 
\end{align*}

The only property here that may not be immediately intuitive is the last one.
But observe that $S_1 - S_2 = \{s \in S_1 : s \not\in S_2\}$. Now, let
$\chi_{S_1}(\overrightarrow{x}, \overrightarrow{\alpha}) = a,
\chi_{S_2}(\overrightarrow{x}, \overrightarrow{\alpha}) = b$. Evidently, if the
$n+m$-tuple is in $S_1$ but not in $S_2$, $a - b = 1$. If the tuple is in both
sets, $a - b = 0$. Etc.

\begin{theorem}
    A rectangular set $S_1 \times  \ldots \times  S_n \times  L_1 \times  \ldots
    L_m$ is $\Sigma$-p.r. if and only if each $S_1, \ldots, S_n, L_1, \ldots,
    L_m$ is $\Sigma$-p.r.
\end{theorem}

This theorem is important, insofar as it allows us to evaluate whether a
Cartesian product is $\Sigma$-p.r. only by looking at its set factors. This
theorem should follow from the properties of primitive recursive sets mentioned
before.

\begin{theorem}
    If $f \sim (n, m, \Omega)$ is $\Sigma$-p.r (not necessarily $\Sigma$-total) and $S$ is a $\Sigma$-p.r. set,
    then $f_{\mid S}$ is $\Sigma$-p.r. 
\end{theorem}

The previous theorem is useful in proving a function is $\Sigma$-p.r. For
example, let $P = \lambda x\alpha\beta \gamma \left[  x = |\gamma| \land \alpha
= \gamma^{Pred(|\beta|)}\right] $. We cannot use the fact that both predicate
functions are $\Sigma$-p.r. to conclude that $P$ is $\Sigma$-p.r., because $P_1
= \lambda x\alpha [x = |\alpha|]$ and $P_2 = \lambda x \alpha \beta \gamma
[\alpha =
\gamma^{Pred(|\beta|)}]$ do not have the same domains. Simply observe that
$\beta$ cannot take the value $\varepsilon$ in $P_2$, but it can take in $P_1$.


However, observe that $\mathcal{D}_P = \omega \times \Sigma^{*} \times
(\Sigma^{*} - \varepsilon) \times \Sigma^{*} $. This set is $\Sigma$-p.r. because
$\chi_{\mathcal{D}_P}^{1, 3} = \neg \lambda \left[ \alpha = \beta \right] \circ
\left[ p_{3}^{1, 3}, C_{\varepsilon}^{1, 3} \right]$ is $\Sigma$-p.r. Now, we can
safely say that $P = P_{1\mid \mathcal{D}_P} \land P_2$, ensuring with the
restriction that both predicates have the same domain. Since $\mathcal{D}_P$ is
$\Sigma$-p.r. so is $P_{1\mid \mathcal{D}_P}$, form which readily follows that
so is $P$. $\blacksquare$

\begin{theorem}
    A set $S$ is $\Sigma$-p.r. if and only if it is the domain of a
    $\Sigma$-p.r. function.
\end{theorem}

\subsection{Case division}

If $f_1, \ldots, f_n$ are s.t. $D_{f_j} \cap D_{f_k} = \emptyset$ for $j \neq k$
and $f_j \mapsto \Omega$, then $\mathcal{F} = f_1 \cup \ldots \cup f_n$ is s.t. 

\begin{align*}
    \mathcal{F} : D_{f_1} \cup \ldots \cup D_{f_n} &\to \Omega \\
    e &\to \begin{cases}
        f_1(e) & e \in D_{f_1} \\ 
               \vdots \\ 
        f_n(e) & e \in D_{f_n}
    \end{cases}
\end{align*}

Under the same constraints, if $f_i$ is $\Sigma$-p.r. for all $i$, then
$\mathcal{F}$ is $\Sigma$-p.r. This reveals a proving method. Given a function
$\mathcal{H}$, we can prove it is $\Sigma$-p.r. by proving it is the union of
$\Sigma$-p.r. functions, under the constraint that the domains of these
functions are disjoint.

For example, this can be used to prove that $\lambda \alpha\left[ \left[ \alpha
\right]_i  \right] $ is $\Sigma$-p.r. Assume a language $\Sigma$. Then

\begin{align*}
    [\alpha a]_i &= \begin{cases}
        a & i = |\alpha| + 1 \\ 
        [\alpha]_i & \text{otherwise}
    \end{cases}\\
\end{align*}

for any $a \in \Sigma$. The base case is the trivial $[\varepsilon]_i = \varepsilon$.
From this follows  that $R = [\alpha]_i \sim (1, 1)$ is difined via primitive recursion by
$f = C_{\varepsilon}^{1, 0}$ and $\mathcal{G}$ an indexed family where
$\mathcal{G}_a$ is of the form above for every $a$. Evidently $f$ is
$\Sigma$-p.r.; now we want to prove $\mathcal{G}_a$ is $\Sigma$-p.r. for any $a
\in \Sigma$.


Observe that the sets $S = \left\{ (i, \alpha, \zeta) : i = |\alpha| + 1 \right\} $
and its complement $\overline{S}$ are disjoint and $\Sigma$-p.r. (We skip the
proof of this statement.) It follows from the division by cases that

\begin{align*}
    \mathcal{G}_a = p_3^{1, 2}_{\mid S} \cup C_{a}^{1, 2}_{\mid \overline{S}}
\end{align*}

is $\Sigma$-p.r. Thus, $R = [\alpha]_i$ is $\Sigma$-p.r.


\small
\begin{quote}

\begin{problem}
    Let $\Sigma = \{@, \$\}$. Let $h : \mathbb{N} \times  \Sigma^{+} \mapsto \omega$
    be $x^2$ if $x + |\alpha|$ is even, $0$ otherwise. Prove that $f$ is
    $\Sigma$-p.r.
\end{problem}

\textit{Complete.}


\begin{problem}
    Let $h$ have $\mathcal{D}_{h} = \{(x, y, \alpha) : x \leq y\}$ and be s.t.
    $R \mapsto x^2$ if $|\alpha| \leq y$, zero otherwise. Show $h$ is $\Sigma$-p.r.
\end{problem}

Let $S := \left\{ (x, y, \alpha) \in \mathcal{D}_h : y \leq |\alpha| \right\}$.
Evidently, $h = f_1 = C_{0}^{2, 3}$ when $|\alpha| > y$ (this is, when the argument is
in $\overline{S}$). When the argument is in $S$, it is $f_2 = \lambda x[x^2] \circ
[p_1^{2, 1}]$. It is trivial to observe both functions are $\Sigma$-p.r. Then $h
= f_{1\mid \overline{S}} \cup f_{2\mid S}$, where of course $S \cup \overline{S}
= \mathcal{D}_h$.

\end{quote}
\normalsize


\subsection{Summation, product and concatenation}

Let $f \sim (n + 1, m, \#)$ with domain $\mathcal{D}_f = \omega \times  S_1 \times \ldots
\times  S_n \times L_1 \times \ldots \times   L_m$, with $S_i \subseteq \omega, L_i \subseteq
\Sigma^{*}$. Then we define $\sum_{t =
x}^{t = y} f(t, \overrightarrow{x}, \overrightarrow{\alpha})$ in the usual way,
with the constraint that the sum is $0$ if $y > x$. In the same way we deifne
$\prod_{t = x}^{t = y} f(t, \overrightarrow{x}, \overrightarrow{\alpha})$ and
the concatenation $\mathop{\subset}_{t=x}^{t=y}f(t, \overrightarrow{x},
\overrightarrow{\alpha})$ for the case $I_f \subseteq \Sigma^{*}$.

The domain of each of these is $\mathcal{D} = \omega \times  \omega \times S_1
\times\ldots \times S_n \times L_1 \times  \ldots \times L_m$, where the first
two $\omega$ elements are the $x, y$ domains of the sum.

\begin{theorem}
    If $f$ is $\Sigma$-p.r. then the functions are $\Sigma$-p.r.
\end{theorem}

To understand why, let $G = \lambda tx \overrightarrow{x}\overrightarrow{\alpha}
\left[\sum_{i=x}^{i=t} f(i, \overrightarrow{x},
\overrightarrow{\alpha})\right]$. Evidently, $G = \circ \left[ p_2^{n+2, m},
p_1^{n + 2, m}, p_3^{n+2, m}, \ldots, p_{n+2+m}^{n+2, m} \right] $ and so we
only need to prove $G$ is $\Sigma$-p.r. Observe that 

\begin{align*}
    G(0, x, \overrightarrow{x}, \overrightarrow{\alpha}) &= \begin{cases}
        0 & x > 0 \\ 
        f(0, \overrightarrow{x}, \overrightarrow{\alpha}) & x = 0
    \end{cases} \\ 
    G(t + 1, x, \overrightarrow{x}, \overrightarrow{\alpha}) &= \begin{cases}
        0 & x > t  +1 \\ 
        G(t, x, \overrightarrow{x}, \overrightarrow{\alpha}) + f(t+1,
        \overrightarrow{x}, \overrightarrow{\alpha})
    \end{cases}
\end{align*}

Thus, if we let each of these functions be called $h, g$ we have that $G = R(h,
g)$. Suffices to show $h, g$ are $\Sigma$-p.r. This can be proven using
division by cases and domain restriction.


\small
\begin{quote}


\begin{problem}
    Prove that $G = \lambda x x_1 \left[ \sum_{t=1}^{t=x} Pred(x_1)^t \right] $ is
    $\Sigma$-p.r.
\end{problem}

We know $f = \lambda xt \left[ Pred(x)^t \right] $ is $\Sigma$-p.r. (trivial to
show). Let $\mathcal{G} = \lambda xy x_1 \left[ \sum_{t=x}^{t=y} f(x_1, t)
\right] $. We know from the last theorem that $\mathcal{G}$ is $\Sigma$-p.r. It
is evident that $G = \mathcal{G} \circ
\left[ C_1^{2, 0}, p_{1}^{2, 0}, p_{2}^{2, 0} \right] $. Then $G$ is
$\Sigma$-p.r. $\blacksquare$

\textit{Show it to me.} Well, $G(x, x_1) = \left( \mathcal{G} \circ \left[
C_{1}^{2, 0}, p_1^{2, 0}, p_2^{2, 0} \right]  \right)(x, x_1) = \mathcal{G}(0,
x, x_1) = \sum_{t=0}^{t=x} f(x_1, t)$.

\begin{problem}
    Show that $G = \lambda xy\alpha \left[ \prod_{t = y+1}^{t = |\alpha|} (t + |\alpha|)
    \right] $ is $\Sigma$-p.r.
\end{problem}

It is trivial to show $f = \lambda t\alpha \left[ t + |\alpha| \right] $ is
$\Sigma$-p.r. Let 

\begin{align*}
    \mathcal{G} = \lambda xy \alpha \left[ \prod_{t=x}^{t = y} (t + |\alpha|) \right] 
\end{align*}

which is $\Sigma$-p.r. Observe that $G(x, y, \alpha) = \mathcal{G}(y + 1,
|\alpha|,
\alpha)$. Then 

\begin{align*}
    G = \mathcal{G} \circ \left[ Suc \circ p_2^{2, 1}, \lambda \alpha[|\alpha|]
    \circ p_{3}^{2, 1}, p_3^{2, 1} \right]
\end{align*}

Then $G$ is $\Sigma$-p.r. $\blacksquare$

\begin{problem}
Prove that 

\begin{align*} \lambda xyz\alpha\beta \left[ \mathop{\subset}_{t=3}^{t=z+5}
    \alpha^{Pred(z) \cdot t} \beta^{Pred\left( Pred\left( |\alpha| \right)
\right) } \right] 
\end{align*}

is $\Sigma$-p.r.
\end{problem}

Let $G$ denote the function in question. First of all, observe that
$\mathcal{D}_G = \omega^2  \times \mathbb{N} \times \Sigma^{*}^2$---which means
$G$ is not $\Sigma$-total. Let us divide our proof by parts. 

\textit{(1)} Let $\mathcal{F} = \lambda xy \alpha \beta \left[ \alpha^{Pred(x)
\cdot y} \beta^{Pred(Pred(|\alpha|))} \right] $, where evidently $\mathcal{F}
\sim (2, 2, *)$ with $x \in \mathbb{N}$. Observe that 

\begin{align*}
    \mathcal{F}_1 &:= \lambda
    xy \alpha \left[ \alpha^{Pred(x)y} \right]\\ &= \lambda x\alpha \left[ \alpha^{x}
    \right] \circ \left[ \lambda xy\left[ xy \right] \circ \left[Pred \circ
    p_{1}^{2, 1}, p_{2}^{2, 1}\right], p_3^{2, 1} \right]   \\ 
    \mathcal{F}_2 &:= \lambda \alpha \beta \left[ \alpha^{Pred(Pred(|\alpha|))}
        \right] \\&= \lambda x\alpha[\alpha^x] \circ \left[ p_1^{0, 2}, Pred \circ
    \left[ Pred \circ \left[ \lambda \alpha [|\alpha|] \circ p_2^{0, 2} \right]  \right]  \right] 
\end{align*}

and evidently 

\begin{align*}
    \mathcal{F} &= \lambda xy\alpha\beta [\mathcal{F}_1(x, y, \alpha)
    \mathcal{F}_2(\beta, \alpha)]\\ &= \lambda \alpha\beta [\alpha\beta] \circ \left[
\mathcal{F}_1 \circ \left[ p_1^{2, 2}, p_2^{2, 2}, p_3^{2, 2} \right],
\mathcal{F}_2 \circ \left[ p_4^{2, 2}, p_3^{2, 2} \right]   \right]
\end{align*}

This proves $\mathcal{F}$ is $\Sigma$-p.r. 

\textit{(2)} It is evident that $G = \lambda xyz \alpha \beta
\left[\mathop{\subset}_{t=3}^{t=z+5} \mathcal{F}(z,
t, \alpha, \beta )\right]$. If we let 

\begin{align*}
    \mathcal{G} := \lambda xyz \alpha\beta \left[ \mathop{\subset}_{t=x}^{t=y}
    \mathcal{F} (z, t, \alpha, \beta)\right] 
\end{align*}

it is evident that $G = \mathcal{G} \circ \left[ C_{3}^{3, 2}, \lambda z [z + 5]
    \circ p_3^{3, 2},
p_3^{3, 2}, p_4^{3, 2}, p_5^{3, 2} \right] $. Then $G$ is $\Sigma$-p.r. $\blacksquare$

\end{quote}
\normalsize

\subsection{Predicate quantification}

If $P : S_0 \times S_1 \times \ldots \times S_n \times L_1 \times \ldots \times
L_m $ is a predicate and $S \subseteq S_0$, then 

$(\forall t \in S)_{t \leq x}P(t, \overrightarrow{x}, \overrightarrow{\alpha})$ is $1$ when $P(t,
\overrightarrow{x}, \overrightarrow{\alpha}) = 1$ for all $t \in \{u \in S: u
\leq x\}$. The domain of the quantified proposition is $\omega \times S_1 \times
\ldots \times S_n \times L_1 \times \ldots \times L_m $, where the first
argument (accounted by $\omega$) is the upper bound $x$. We generalize, where $L
\subseteq L_{m+1}, S \subseteq S_0$:


\begin{align*}
    (\forall t \in S)_{t \leq x}P(t, \overrightarrow{x},
    \overrightarrow{\alpha})  
    &: \omega \times S_1 \times \ldots \times S_n \times L_1 \times \ldots \times L_m \to \{0, 1\}\\ 
    (\exists t \in S)_{t \leq x}P(t, \overrightarrow{x},
    \overrightarrow{\alpha}) 
    &: \omega \times S_1 \times \ldots \times S_n \times L_1 \times \ldots \times L_m \to \{0, 1\}\\ 
    (\forall \alpha \in L)_{|\alpha| \leq x}P(\overrightarrow{x},
    \overrightarrow{\alpha}, \alpha) 
    &: \omega \times S_1 \times \ldots \times S_n \times L_1 \times \ldots \times L_m \to \{0, 1\}\\ 
    (\exists \alpha \in L)_{|\alpha| \leq x}P(\overrightarrow{x},
    \overrightarrow{\alpha}, \alpha) 
    &: \omega \times S_1 \times \ldots \times S_n \times L_1 \times \ldots \times L_m \to \{0, 1\}
\end{align*}

It is important to observe that the set over which the quantification is done is
a subset of the set from which comes the driving variable $t$ (in the numeric
case) or $\alpha$ (in the alphabetic case).

\begin{theorem}
    \textit{(1)} If $P: S_0 \times S_1 \times \ldots \times S_n \times L_1 \times
    \ldots \times L_m  \to \omega$ a predicate $\Sigma$-p.r., and $S \subseteq
    S_0$ is $\Sigma$-p.r., then both quantifications over $P$ are $\Sigma$-p.r.


    \textit{(2)} If $P: S_1 \times \ldots \times S_n \times L_1 \times
    \ldots \times L_m  L_{m+1} \to \omega$ a predicate $\Sigma$-p.r., and $L \subseteq
    L_{m+1}$ is $\Sigma$-p.r., then both quantifications over $P$ are $\Sigma$-p.r.
\end{theorem}

   
The theorem above states that the quantification over a $\Sigma$-p.r. set of a
$\Sigma$-p.r. predicate is itself $\Sigma$-p.r. Though unbounded quantification
does not preserve these properties, in general a bound exists "naturally" for
quantifications, which serves to prove that a bounded quantification is
$\Sigma$-p.r.. Consider the following example.

~

\textit{Example.} The predicate $\lambda xy[x \mid y]$ is $\Sigma$-p.r, because
$P = \lambdat x_1 x_2 [x_2 = tx_1]$ is $\Sigma$-p.r. Since $P$ is $\Sigma$-p.r.,
any \textbf{bounded} quantification of it over a $\Sigma$-p.r. set is itself
$\Sigma$-p.r. For example, 

\begin{align*}
    \lambda x x_1 x_2 \left[(\exists t \in \omega)_{t \leq x} x_2 = tx_1\right]
\end{align*}

is $\Sigma$-p.r. Now, observe that if $x_2 = tx_1$ then it is necessary that $t
\leq x_2$. But 

\begin{align*}
    &\lambda x_1 x_2 \left[(\exists t \in \omega)_{t \leq x_2} ~  x_2 =
tx_1\right] \\ = 
    &\lambda x x_1 x_2 \left[(\exists t \in \omega)_{t \leq x} x_2 = tx_1\right]
    \circ \left[ p_{2}^{2, 0}, p_1^{2, 0}, p_2^{2, 0} \right] 
\end{align*}

Then the \textbf{bounded} quantification, with $x_2$ as bound, is $\Sigma$-p.r.



\small
\begin{quote}


\begin{problem}
    Let $\Sigma = \{@, !\}$. Show that $S = \{(2^x, @^x, !) : x \in \omega \land x \text{ impar}\}$ is $\Sigma$-p.r.
\end{problem}

For clarity, observe that a few elements of
$S$ are 

\begin{align*}
    (2, @, !), (8, @@@, !), (32, @@@@@, !), \ldots
\end{align*}


Let $P_1 = \lambda xy\alpha \left[ x = 2^{y +1} \right], P_2 =
\lambda xy\alpha[\alpha = @^{y + 1}] $. It is clear that $\mathcal{D}_{P_1} =
\mathcal{D}_{P_2}$. It is trivial to prove that both are $\Sigma$-p.r. Then $P_1
\land P_2$ is $\Sigma$-p.r. Then

\begin{align*}
    \chi_{S}^{1, 2} = \lambda xy \alpha \beta \left[ (\exists k \in \omega)_{k \leq
        x} \left( P_1(y, k, \alpha) \land P_2(y, y, \alpha)\right) 
 \land \beta = !  \right] 
\end{align*}

is $\Sigma$-p.r.

\end{quote}
\normalsize


\subsection{Minimization of numeric variable}

Let $P$ an arbitrary predicate over a numeric variable. If there is some $t \in
\omega$ s.t. $P(t, \overrightarrow{x}, \overrightarrow{\alpha})$ holds, we use
$\min_{t} P(t, \overrightarrow{x}, \overrightarrow{\alpha})$ to denote the
minimum $t$ that holds. This is \textbf{not defined} if there is no tuple
$(\overrightarrow{x}, \overrightarrow{\alpha})$ over which the predicate holds.
Furthermore, $\min_t P(t, \overrightarrow{x}, \overrightarrow{\alpha}) = \min_i
P(i, \overrightarrow{x}, \overrightarrow{\alpha})$; this is, $\min_t$ does not
depend on the variable $t$.

~ 

We define 

\begin{align*}
    M(P) = \lambda \overrightarrow{x}\overrightarrow{\alpha} \left[ \min_t P(t,
    \overrightarrow{x}, \overrightarrow{\alpha}) \right] 
\end{align*}

We say $M(P)$ is obtained via minimization of the numeric variable from $P$.

\textit{Example.} Let $Q : \omega \times \mathbb{N}$ be s.t. $Q(x, y)$ denotes
the quotient of $\frac{x}{y}$. This quotient is by definition the maximum
element of $\{t \in \omega : ty \leq x\}$. Let $P = \lambda txy \left[ ty \leq x
\right] $. Observe that 

\begin{align*}
    \mathcal{D}_{M(P)} = \left\{ (x, y) \in \omega^2 : (\exists t \in \omega)
    P(t, x, y) = 1 \right\} 
\end{align*}

If $(x, y) \in \omega \times \mathbb{N}$, one can show that $\min_t x < ty =
Q(x, y) + 1$. Then $M(P) = Suc \circ Q$.

\textbf{The U rule}. If $f$ is a $\Sigma$-mixed function with type $(n, m, \#)$
and we want to find a predicat $P$ s.t. $f = M(P)$, it is sometimes useful to
design $P$ so \hat{t} 

\begin{align*}
    f(\overrightarrow{x}, \overrightarrow{\alpha}) = \text{only } t \in \omega
    \text{ s.t. } P(t, \overrightarrow{x}, \overrightarrow{\alpha})
\end{align*}


\small
\begin{quote}


\begin{problem}
    Use the \textbf{U rule} to find a predicate $P$ s.t. $M(P) = \lambda
    x[\text{integer part of } \sqrt{x}]$ .
\end{problem}

Let $f(x)$ denote the integer part of $\sqrt{x}$. If $f(x) = y$ then $y^2 \leq x
\land (y+1)^2 > x$. Then letting $P = \lambda xy\left[ x^2 \leq y \land (x +
1)^2 > y \right] $ ensures that $M(P(x, y)) = f(x)$.

\begin{problem}
    Find $P$ s.t. $M(P) = \lambda xy\left[ x - y \right] $.
\end{problem}

Since $x - y$ is unique for each pair $x, y$, $P = \lambda xyz [z = x - y]$. Then
$\min_z P(x, y, z) = \lambda xy[x - y]$. For example, $3 - 5 = 0$ and $\min_z
P(3, 5, z) = 0$.

\end{quote}
\normalsize


\begin{theorem}
    If $P$ a predicate that is effectively computable and $\mathcal{D}_P$ is
    effectively computable, then $M(P)$ is effectively computable.
\end{theorem}

\subsection{Recursive function}

Now we define $R_0^{\Sigma} = PR_0^{\Sigma}$ and 

\begin{align*}
    R_{k+1}^{\Sigma} = &R_k^{\Sigma} \\ \cup &\left\{ f \circ \left[ f_1, \ldots,
    f_n \right] : f_i \in R_{k}^{\Sigma} \right\} \\ \cup &\{R(f, g) : f, g \in
R_k^{\Sigma}\} \\ \cup & \left\{M(P) : \text{P is $\Sigma$-total} \land P \in
R_k^{\Sigma}\right\}
\end{align*}

In other words, recursive functions are all primitive recursive functions plus
all predicate minimization functions over $\Sigma$-total and recursive
predicates.

We define $R^{\Sigma} = \bigcup_{k\geq 0} R_{k}^{\Sigma}$.

\begin{theorem}
    If $f \in R^{\Sigma}$ then $f$ is $\Sigma$-effectively computable.
\end{theorem}

\begin{theorem}
    Not every $\Sigma$-recursive function is $\Sigma$-p.r. In other words, 

    \begin{align*}
        PR^{\Sigma} \subseteq R^{\Sigma} \text{ but } PR^{\Sigma} \neq R^{\Sigma}
    \end{align*}
\end{theorem}

It is obvious by definition that if $f$ is $\Sigma$-p.r. then it is recursive.
But if a function is recursive, it could very well be a minimization predicate
over a $\Sigma$-total function that is not $\Sigma$-p.r. itself! In other words, 

\begin{align*}
    R^{\Sigma} - PR^{\Sigma} = \left\{ M(P) : P \text{ is $\Sigma$-p.r.}  \land
    P \in R^{\Sigma} \land M(P) \text{ is not $\Sigma$-p.r.} \right\} 
\end{align*}

In fact, the theorems in previous sections ensured that if $P$ is $\Sigma$-p.r.
and so is $\mathcal{D}_P$, then $M(P)$ is $\Sigma$-effectively computable. Which
doesn't entail that it is $\Sigma$-p.r.

\begin{theorem}
    If $P \sim (n+1, m, \#)$ is a $\Sigma$-p.r. predicate then \textit{(1)} $M(P)$ is
    $\Sigma$-recursive. If there is a $\Sigma$-p.r.function $f \sim (n, m, \#)$
    s.t. $M(P)(\overrightarrow{x}, \overrightarrow{\alpha}) = \min_t P(t,
    \overrightarrow{x},  \overrightarrow{\alpha}) \leq f(\overrightarrow{x},
    \overrightarrow{\alpha})$ for all $(\overrightarrow{x},
    \overrightarrow{\alpha}) \in \mathcal{D}_{M(P)}$, then $M(P)$ is $\Sigma$-p.r.
\end{theorem}

The theorem above gives the conditions to say whether $M(P)$ is recursive and
whether it is $\Sigma$-p.r. It is recursive simply if $P$ is $\Sigma$-p.r. And
it is $\Sigma$-p.r. if $M(P)$ is bounded by some function $f$ for all values in
the domain of $M(P)$. 

\begin{theorem}
    The quotient function, the remainder function, and the $i$th prime function are $\Sigma$-p.r.
\end{theorem}

\subsection{Minimization of alphabetic variable}

We define $M^{\leq}(P) = \lambda \overrightarrow{x} \overrightarrow{\alpha}
\left[ \min_{\alpha}^{\leq} P(\overrightarrow{x}, \overrightarrow{\alpha},
\alpha) \right] $, where $\leq$ is some order over the language $\Sigma$ in
question.

\begin{theorem}
    If $P$ is $\Sigma$-p.r. predicate over a string, then the same conditions
    apply for $M(P)$ to be $\Sigma$-p.r. as in the theorem for predicates over
    numbers.
\end{theorem}


\small
\begin{quote}


\begin{problem}
    Prove that $\lambda \alpha[\sqrt{\alpha} ]$ is $\Sigma$-p.r.
\end{problem}

Observe that $\lambda \alpha \left[ \sqrt{\alpha}  \right] = \min_{\alpha}
\lambda \alpha \beta [\beta = \alpha \alpha]$. The predicate, which we call $P$,
is trivially $\Sigma$-p.r. This means that $\lambda \alpha[\sqrt{ \alpha } ] \in
R^{\Sigma}$. 

Let $M(P)$ denote the minimization above. Then $M\left(P\left(\alpha,
\beta\right)\right) \leq \beta$. In other words, $M(P)$ is bounded by $f =
\lambda \alpha [\alpha]$. Then $\lambda \alpha [\sqrt{\alpha} ] \in
PR^{\Sigma}$.

\end{quote}
\normalsize


\subsection{Enumerable sets}

We say $S \subseteq \omega^n \times \Sigma^{*2}$ is $\Sigma$-recursively
enumerable if it is empty or there is a function $\mathcal{F} : \omega \to
\omega^n \times \Sigma^{*2}$ s.t.

\begin{itemize}
    \item $Im_{\mathcal{F}} = S$ 
    \item $\mathcal{F}_{(i)}$ is $\Sigma$-recursive for every $1 \leq 1 \leq n + m$.
\end{itemize}

Here, $\Sigma$-recursive functions model $\Sigma$-computable functions.

\subsection{Recursive sets}

The Godelian model of a $\Sigma$-effectively computable set is simple. A set $S$
is $\Sigma$-recursive when $\chi_{S}$ is $\Sigma$-recursive.

\subsection{Alphabet independence}

\begin{theorem} Let $\Sigma, \Gamma$ two alphabets. If $f$ is $\Sigma$-mixed and
$\Gamma$-mixed, then $f$ is $\Sigma$-recursive iff it is $\Gamma$-recursive. The
analogue applies to recursive sets and this extends to primitive recursion.
\end{theorem}

The theorem above states that recursiveness or primitive-recursiveness is
independent of any given alphabet.


\pagebreak 

\section{Neumann}

\subsection{The $\mathcal{S}^{\Sigma}$ language}

We provide von Neumann's model of $\Sigma$-effectively computable function. We
use $Num = \{0, 1, \ldots, 9\}$ a set of \textit{symbols} (not numbers) and
define $S : Num^{*} \mapsto Num^{*}$ as 

\begin{align*}
    S(\varepsilon) &= 1 \\
    S(\alpha 0) &= \alpha 1 \\
    S(\alpha 2) &= \alpha 3 \\
                &\vdots \\ 
    S(\alpha 9) &= S(\alpha) 0
\end{align*}

It is easy to observe that $S$ is a "counting" or "enumerating" function of the
alphabet $Num$. We define 

\begin{align*}
    \text{---} : \omega &\mapsto  Num^{*}  \\ 
    \overline{0} & \mapsto \varepsilon \\ 
    \overline{n + 1} &\mapsto S(\overline{n})
\end{align*}

In other words, $\overline{n}$ simply denotes the alphabetic symbol of $Num$
that denotes the number $n$. The whole syntax of the $S^{\Sigma}$ language is
given by $\Sigma \cup \Sigma_p$, where

\begin{align*}
    \Sigma_p = Num \cup \{ \leftarrow, +, \overline{-}, ~ . ~, \neq, {}^{\curvearrowright},
    \varepsilon, N, K, P, L, I, F, G, O, T, B, E, S \}
\end{align*}

It is important to note that these are \textit{symbols} or \textit{strings}, not
values. The $\varepsilon$ in $\Sigma_p$ is not the empty letter, but the symbol
that denotes it. The $\overline{+}, -$ signs are not the operations plus and
minus, but the same symbols that denote these operations. 

\subsection{Variables, labels, and instructions}

Any word of the form $N \overline{k}$ is a numeric variable; $P \overline{k}$ is
an alphabetic variable; $L \overline{k}$ is a label.

The basic instructions in $\mathcal{S}^{\Sigma}$ make use of these; for a list
of the instructions, consult the original source. In general, an instruction of
$\mathcal{S}^{\Sigma}$ is any word of the form $\alpha I$, where $\alpha \in \{L
\overline{n}: n \in \mathbb{N}\}$ and $I$ is a basic instruction. We use
$Ins^{\Sigma}$ to denote the set of all instructions in $\mathcal{S}^{\Sigma}$.
When $I = L \overline{n} J$ and $J$ a basic instruction, we say $L \overline{n}$
is the label of $J$.

\subsection{Programs in $\mathcal{S}^{\Sigma}$}

A program in $\mathcal{S}^{\Sigma}$ is any word $I_1 \ldots I_n$, with $n \geq
1$, s.t. $I_k \in Ins^{\Sigma}$ for all $1 \leq k \leq n$ and the following
property holds:

\textbf{GOTO Law}: For every $1 \leq i \leq n$, if $GOTOL \overline{m}$ is
the end of $Ii$, then there is some $j, 1 \leq j \leq n$, s.t. $I_j$ has label
$L \overline{m}$.

Informally, a program is any chain of instructions satisfying that GOTO
instructions map to actual labels in the program.

~ 

We use $Pro^{\Sigma}$ to denote the set of all programs in
$\mathcal{S}^{\Sigma}$.

\begin{theorem}
    Let $\Sigma$ a finite alphabet. Then 

    \begin{itemize}
        \item If $I_1 \ldots I_n = J_1 \ldots J_n$, with $I_k, J_k \in
            Ins^{\Sigma}$, then $n = m$ and $I_k = J_k$ for all $k$.
        \item If $\mathcal{P} \in Pro^{\Sigma}$ then there is a unique set of
            instructions $I_1 \ldots I_n$ s.t. $\mathcal{P} = I_n \ldots I_n$.
    \end{itemize}
\end{theorem}

The theorem above establishes that any program in $Pro^{\Sigma}$ is a
\textit{unique} concatenation of instructions. We use $n(\mathcal{P})$ to denote
the number of instructions that make up $\mathcal{P} \in Pro^{\Sigma}$. By
convention, if $\mathcal{P} = I^{\mathcal{P}}_1 \ldots
I^{\mathcal{P}}_{n(\mathcal{P})}$, then $I^{\mathcal{P}}_j =
\varepsilon$ if $j \not\in [1, n(\mathcal{P})]$. In other words, we understand that
a program contains infinitely many empty symbols to the right and left (like in
Turing machines).

\textit{Observation.} $n(\alpha)$ and $I_j^{\alpha}$ are defined only when
$\alpha \in Pro^{\Sigma}, i \in \omega$. This means the domain of $\lambda
\alpha[n(\alpha)]$ is $Pro^{\Sigma} \subseteq \Sigma \cup \Sigma_p$ and that of
$\lambda i\alpha[I_i^{\alpha}]$ is $\omega \times Pro^{\Sigma}$.


\small
\begin{quote}


\begin{problem}
    Is is true that $Ins^{\Sigma} \cap Pro^{\Sigma} = \emptyset$? And is it true
    that $\lambda i \mathcal{P} [I_i^{\mathcal{P}}]$ has domain $\left\{ (i,
    \mathcal{P}) \in \mathbb{N} \times Pro^{\Sigma}: i \leq n(\mathcal{P})
\right\} $?
\end{problem}

Both statements are false. A single instruction in $Ins^{\Sigma}$ can be a
program (as long as it is not a GOTO statement to a non-existent label).
Furthermore, $\lambda i \mathcal{P} [I_i^{\mathcal{P}}]$ is defined for $i = 0$
(it maps to $\varepsilon$) and for $i \geq n(\mathcal{P} )$ (it also maps to
$\varepsilon$).

\begin{problem}
    Prove: If $\mathcal{P}_1, \mathcal{P}_2 \in Pro^{\Sigma}$ then $\mathcal{P}_1
    \mathcal{P}_1 = \mathcal{P}_2 \mathcal{P}_2 \Rightarrow \mathcal{P}_1 =
    \mathcal{P}_2$.
\end{problem}

This follows from the theorem that guarantees that any program $\mathcal{P} \in
Pro^{\Sigma}$ is a \textit{unique} concatenation of instructions. Let
$\mathcal{P}_1 = I_1^{\mathcal{P}_1} \ldots I_{n(\mathcal{P}_1)}^{\mathcal{P}_1}$ and $\mathcal{P}_2 = I_1^{\mathcal{P}_2}
\ldots I_{n(\mathcal{P}_2)}^{\mathcal{P}_2}$. Assume $\mathcal{P}_1\mathcal{P}_1 =
\mathcal{P}_2 \mathcal{P}_2$. Then 

\begin{align*}
    I_1^{\mathcal{P}_1} \ldots I_{n(\mathcal{P}_1)}^{\mathcal{P}_1}
    I_1^{\mathcal{P}_1} \ldots I_{n(\mathcal{P}_1)}^{\mathcal{P}_1} = 
    I_2^{\mathcal{P}_2} \ldots I_{n(\mathcal{P}_2)}^{\mathcal{P}_2}
    I_2^{\mathcal{P}_2} \ldots I_{n(\mathcal{P}_2)}^{\mathcal{P}_2}
\end{align*}

Then, from the last theorem follows that $I_k^{\mathcal{P}_1} =
i_k^{\mathcal{P}_2}$. From this follows directly that $\mathcal{P}_1 =
\mathcal{P}_2$. $\blacksquare$

\end{quote}
\normalsize


\subsection{States in programs of $\mathcal{S}^{\Sigma}$}.

We define $Bas : Ins^{\Sigma} \mapsto (\Sigma \cup \Sigma_p)^{*}$, the program
that returns the substring of an instruction corresponding to its basic
instruction, as 

\begin{align*}
    Bas(I) = \begin{cases}
        J & I = L \overline{k} J \\ 
        I & \text{otherwise}
    \end{cases}
\end{align*}

Recall that 

\begin{align*}
    {}^{\curvearrowright} \alpha = \begin{cases}
        [\alpha]_2 \ldots \alpha_|\alpha| & |\alpha| \geq 2 \\ 
        \varepsilon & \text{otherwise}
    \end{cases}
\end{align*}

We define $\omega^{\mathbb{N}} = \{ (s_1, s_2, \ldots) : \exists n \in
\mathbb{N} : i > n \Rightarrow s_i = 0 \}$. This is, $\omega^{\mathbb{N}}$
denotes the set of infinite tuples that from some index onwards contain only
zeroes. Similarly, $\Sigma^{*\mathbb{N}}$ denotes the set of infinite alphabetic
tuples that contain only $\varepsilon$ from some index onwards.

A \textbf{state} is a tuple $(\overrightarrow{s}, \overrightarrow{\sigma}) \in
\omega^{\mathbb{N}} \times \Sigma^{*\mathbb{N}}$. If $i \geq i$ we say $s_i$ has
the value of the ${N} \overline{i}$ variable in the state, and $\sigma_i$ the
value of the $P \overline{i}$ variable in the state. Thus, a state is a pair of
infinite tuples containing the values of the variables in a program.

We use 

\begin{align*}
    [\![ x_1, \ldots x_n, ~ \alpha_1, \ldots, \alpha_m ]\!]
\end{align*}

to denote the state $\left( (x_1, \ldots, x_n, 0, 0, \ldots), (\alpha_1, \ldots,
\alpha_m, \varepsilon, \varepsilon,\ldots) \right) $.

\subsection{Instantaneous description of a program in $\mathcal{S}^{\Sigma}$}

Since a program $\mathcal{P} \in Pro^{\Sigma}$ may contain GOTO instructions,
it is not always the case that $I_{k+1}^{\mathcal{P}}$ is executed after
$I_k^{\mathcal{P}}$. Thus, when running a program, we not only need to consider
its state but the specific instruction to be executed. An instantaneous
description is a mathematical object which describes all this information.

Formally, an instantaneous description is triple $(i, \overrightarrow{s},
\overrightarrow{\alpha}) \in \omega \times \omega^{\mathbb{N}} \times
\Sigma^{*\mathbb{N}}$. This Cartesian product is the set of all possible
instantaneous descriptions. The triple reads: The following instruction is
$I_{i}^{\mathcal{P}}$ and the current state is $(\overrightarrow{s},
\overrightarrow{\sigma})$. Observe that if $i \not\in [1, n(\mathcal{P})]$, then
the description reads: We are in state $(\overrightarrow{s},
\overrightarrow{\sigma})$ and we must execute $\varepsilon$ (nothing).

We define the successor function

\begin{align*}
    S_\mathcal{P} : \omega \times \omega^{\mathbb{N}} \times
    \Sigma^{*\mathbb{N}} \mapsto  \omega \times \omega^{\mathbb{N}} \times \Sigma^{*\mathbb{N}}
\end{align*}

which maps an instantaneous description to the successor instantaneous
description (the one after executing the instruction in the first). 

\subsection{Computation from a given state}

Let $\mathcal{P} \in Pro^{\Sigma}$ and a state  $(\overrightarrow{s},
\overrightarrow{\sigma})$. The \textit{computation} of $\mathcal{P}$ from
$(\overrightarrow{s}, \overrightarrow{\sigma})$ is defined as 

\begin{align*}
    \left(  (1, \overrightarrow{\sigma}, \overrightarrow{\sigma}),
    S_{\mathcal{P}}\left( 1, \overrightarrow{s}, \overrightarrow{\sigma}
\right), S_{\mathcal{P}} \left( S_{\mathcal{P}} \left( 1, \overrightarrow{s},
\overrightarrow{\sigma} \right)  \right), \ldots   \right) 
\end{align*}

In other words, the \textit{computation} of $\mathcal{P}$ is the infinite tuple
whose $i$th element is the instantaneous description of $\mathcal{P}$ after $i -
1$ instructions have been executed.

We say $S_{\mathcal{P}} \left( \ldots S_{\mathcal{P}} \left(
S_{\mathcal{P}}\left( 1, \overrightarrow{s}, \overrightarrow{\sigma} \right)
\right)  \right) $ is the instantaneous description obtained after $t$ steps if
the number of times $S_{\mathcal{P}}$ was executed is $t$.


\small
\begin{quote}


\begin{problem}
    Give true or false for the following statements.
\end{problem}

\textit{Statement 1: If $S_{\mathcal{P}}(i, \overrightarrow{s},
\overrightarrow{\alpha}) = (i, \overrightarrow{s}, \overrightarrow{\alpha})$
then $i \not\in [1, n(\mathcal{P})]$}. The statement is false. It could be the
case that $i \not\in [1, n( \mathcal{P} )]$, in which case we would say the program
halted. However, consider the program 

\begin{align*}
    L1 ~ GOTO ~ L1 
\end{align*}

Evidently, $S_{\mathcal{P}}(1, \overrightarrow{s}, \overrightarrow{\alpha}) =
(1, \overrightarrow{s}, \overrightarrow{\alpha})$, and $1 \leq 1 \leq
n(\mathcal{P})$ .

\textit{Statement 2. Let $\mathcal{P} \in Pro^{\Sigma}$ and $d$ an instantaneous
description whose first coordinate is $i$. If $I_i^{\mathcal{P}} = N_2
\leftarrow N_2 + 1$, then $$S_{\mathcal{P}}(d) = \left( i+1, \left( N_1,
Suc(N_2), N_3, \ldots \right), (P_1, P_2, P_3, \ldots)  \right) $$}

The statement is true via direct application of the $S_{\mathcal{P}}$ function.

\textit{Statement 3. Let $\mathcal{P} \in Pro^{\Sigma}$ and $(i,
\overrightarrow{s}, \overrightarrow{\sigma})$ an instantaneous description. If
$Bas(I_i^{\mathcal{P}}) = IF ~ P_3 ~ BEGINS ~ a ~ GOTO ~ L_6$ and $[P_3]_1 = a$,
then $S_{\mathcal{P}}(i, \overrightarrow{s}, \overrightarrow{\sigma}) = (j,
\overrightarrow{s}, \overrightarrow{\sigma})$, where $j$ is the least number $l$
s.t. $I_{l}^{\mathcal{P}}$ has label $L_6$}.

Because $[P_3]_1 = a$, the value of $S_{\mathcal{P}}(i, \overrightarrow{s},
\overrightarrow{\sigma})$ must indeed contain the instruction that has label
$L_6$. This instruction is the $j$th instruction for some $j$, etc. The
statement is true.

\end{quote}
\normalsize

\subsection{Halting}

When the first coordinate of  $S_{\mathcal{P}} \left( \ldots S_{\mathcal{P}}
\left( S_{\mathcal{P}}\left( 1, \overrightarrow{s}, \overrightarrow{\sigma}
\right)\right)  \right) $ with $t$ steps is $n(\mathcal{P}) + 1$, we say
$\mathcal{P}$ \textit{halts after $t$ steps when starting from
$(\overrightarrow{s}, \overrightarrow{\sigma})$}.

If none of the first coordinates in the computation of $\mathcal{P}$, 

\begin{align*}
    \left(  (1, \overrightarrow{\sigma}, \overrightarrow{\sigma}),
    S_{\mathcal{P}}\left( 1, \overrightarrow{s}, \overrightarrow{\sigma}
\right), S_{\mathcal{P}} \left( S_{\mathcal{P}} \left( 1, \overrightarrow{s},
\overrightarrow{\sigma} \right)  \right), \ldots   \right) 
\end{align*}

is $n(\mathcal{P})$, we say $\mathcal{P}$ does not halt starting from
$(\overrightarrow{s}, \overrightarrow{\sigma})$.

\subsection{$\Sigma$-computable functions}

We give the model of a $\Sigma$-effectively computable function in the paradigm
of von Neumann. Intuitively, $f$ is $\Sigma$-computable if there is some
$\mathcal{P} \in Pro^{\Sigma}$ that computes it. 

Given $\mathcal{P} \in Pro^{\Sigma}$, for every pair $n,m \geq 0$, we define
$\Psi_{\mathcal{P}}^{n, m, \#}$ as follows: 

\begin{align*}
    \mathcal{D}_{\Psi_{\mathcal{P}}^{n, m, \#}} &= \left\{ (\overrightarrow{x},
    \overrightarrow{\alpha}) \in \omega^n \times \Sigma^{*m} : \mathcal{P}
\text{ halts from } [\![ x_1,\ldots, x_n, \alpha_1, \ldots,
\alpha_m ]\!] \right\}  \\ 
        \Psi_{\mathcal{P}}^{n, m, \#}(\overrightarrow{x}, \overrightarrow{\alpha}) &=
    \text{Value of } N_1 \text{ in halting state from } [\![ x_1,\ldots, x_n,
    \alpha_1, \ldots, \alpha_m ]\!]
\end{align*}

We analogously define $\Psi_{\mathcal{P}}^{n, m, *}$ for the alphabetic case,
where the domain is the same and the value is that of $P_1$ in the halting
state.

~ 

A $\Sigma$-mixed function, not necessarily total, is $\Sigma$-computable if
there is a program $\mathcal{P}} \in Pro^{\Sigma}$ s.t. $f \sim (n, m, \varphi) =
\Psi_{\mathcal{P}}^{n, m, \varphi}$, with $\varphi \in \{\#, *\}$. We say $f$ is
computed by $\mathcal{P}$.

\begin{theorem}
    If $f$ is $\Sigma$-computable, then it is $\Sigma$-effectively computable.
\end{theorem}

The previous theorem should be obvious. Any program in $\mathcal{S}^{\Sigma}$
can be translated into an effective procedure with relative simplicity.


\small
\begin{quote}

\begin{problem}
    Let $\Sigma = \{@, !\}$. Give a program that computes $f : \{0, 1, 2\}
    \mapsto \omega $ given by $f(0) = f(1) = 0, f(2) = 5$.
\end{problem}

Evidently $f \sim (1, 0, \#)$ and so we must find some $\mathcal{P} \in
Pro^{\Sigma}$ s.t. $\Psi_{\mathcal{P}}^{1, 0, \#}(x) = f(x)$. The program must
let $N_1$ hold the value $0$ if the starting state is either $[\![ 0 ]\!]$ or
$[\![ 1 ]\!]$, and the value $5$ if the starting state is $[\![ 2 ]\!]$. In all
other cases, it must not halt, to ensure that the domain of
$\Psi_{\mathcal{P}}^{1, 0, \#}$ is the same as that of $f$. The desired program
is 

\begin{align*}
    &N_2 \leftarrow N_1\\
    &N_2 \leftarrow N_2 - 1\\
    &IF ~ N_2 \neq 0 ~ GOTO ~L_1 \\ 
    &GOTO ~ L_4 \\ 
    L_1 ~ &N_2 \leftarrow N_2 - 1 \\ 
    &IF ~  N_2 \neq 0 ~ GOTO ~ L_2\\
    &GOTO L_3\\
    L_2~& GOTO ~ L_2 \\ 
    L_3 ~ & N_1 \leftarrow N_1 + 1\\
    & N_1 \leftarrow N_1 + 1\\
    & N_1 \leftarrow N_1 + 1 \\ 
    & GOTO ~ L_5 \\
    L_4 ~ & N_1 \leftarrow 0 \\ 
    L_5~& SKIP
\end{align*}

If $\mathcal{P}$ denotes this program, it is evident that $\mathcal{P}$ only
halts for starting states $[\![ x_1 ]\!]$ with $x_1 \in \{0, 1, 2\}$.
Thus, the domain of $\Psi_{\mathcal{P}}^{1, 0, \#}$ is precisely
$\mathcal{D}_f$. It is easy to verify that, more generally,
$\Psi_{\mathcal{P}}^{1, 0, \#} = f$.

\begin{problem}
    Using the same alphabet as in the previous problem, find $\mathcal{P} \in
    Pro^{\Sigma}$ that computes $\lambda xy[x + y]$.
\end{problem}

The desired program is 

\begin{align*}
    L_1 ~ &IF ~ N_2 = 0 ~ GOTO ~ L_3 \\ 
          &N_1 \leftarrow N_1 + 1 \\ 
          &N_2 \leftarrow N_2 - 1 \\ 
          &GOTO ~ L_1\\
    L_3 ~ & SKIP
\end{align*}

\begin{problem}
    Same for $C_0^{1, 1}_{\mid \{0, 1\} \times  \Sigma^{*}}$
\end{problem}

Since the domain of the constant function is restricted t o $\{0, 1\} \times
\Sigma^{*}$, we must ensure the program only halts for states $[\![ x_1, x_2,
\alpha ]\!]$ s.t. $x_1,x_2 \in \{0, 1\}$. Thus, the program is 

\begin{align*}
    &N_1 \leftarrow N_1 - 1 \\
    &N_2 \leftarrow N_2 - 1 \\
    &IF N_2 \neq 0 ~ GOTO ~ L_1 \\ 
    & IF N_1 \neq 0 ~ GOTO ~ L_1 \\ 
    &GOTO ~ L_2 \\ 
    L_1~& GOTO ~ L_1 \\ 
    L_2~ &SKIP
\end{align*}

\begin{problem}
    Same for $\lambda i\alpha[[\alpha]_i]$ (same alphabet).
\end{problem}

\begin{align*}
    &IF ~ N_0 \neq 0 ~ GOTO ~ L_1 \\ 
    &P_1 \leftarrow \varepsilon \\ 
    & GOTO ~ L_{100} \\
    L_1 ~ & N_1 \leftarrow N_1 - 1 \\ 
    L_2 ~ & N_1 \leftarrow N_1 - 1 \\ 
          &P_1 \leftarrow {}^{\curvearrowright} P_1\\
    &IF ~ N_1 \neq 0 ~ GOTO ~ L_2\\
    &IF ~ P_1 ~ STARTSWITH ~ @ ~ GOTO ~ L_2 \\ 
    &IF ~ P_1 ~ STARTSWITH ~ ! ~ GOTO L_3\\ 
    & GOTO L_{100}\\
    L_3~&P_1 \leftarrow ~ !\\
    L_2 ~ &P_1 \leftarrow  @ \\ 
    L_{100} ~ & SKIP
\end{align*}

\textit{Example.} Let $\alpha = @!!@@$. Assume we give $[\![ 4, \alpha ]\!]$.
Since $4 \neq 0$ we go to $L_1$ immediately. Here $N_1$ is set to three. Then
$N_1$ is set to two and $P_1$ is set to $!!@@$. Since $N_1 \neq 0$, $N_1$ is now
set to $1$ and $P_1$ to $!@@$. Once more, $N_1$ is now set to $0$ and $P_1$ to
$@@$. Since now $N_1 = 0$ , we know the starting character of $P_1$ is the one
we looked for. We set $P_1$ to be its first character (if $P_1 = \varepsilon$ it
has no first character and nothings needs to be done, because this means the
input $[\![ x_1, \alpha ]\!]$ had $x_1 > |\alpha|$). The other cases also work.

\begin{problem}
    Give a program that computes $s^{\leq}$ where $@ < !$.
\end{problem}

Recall that $s^{\leq} : \Sigma^{*} \mapsto \Sigma^{*}$ is defined as 

\begin{align*}
    s^{\leq} \left( (a_n)^m \right)  &= (a_1)^{m + 1} & m \geq 0\\ 
    s^{\leq} \left( \alpha a_i (a_n)^{m} \right) &= \alpha a_{i+1} (a_1)^{m} & 1
    \leq i < n, m \geq 0
\end{align*}

In our case, this functions enumerates the language in question as follows: 

\begin{align*}
    \varepsilon, @, !, @ @, @ !, !@, !!, @@@, @@!, @!@, @!!, !@@, !@!, !!@, !!!, \ldots
\end{align*}
\end{quote}
\normalsize

\subsection{Macros}

A macro is the template of a program that computes a $\Sigma$-mixed function.
There are two types: 

\begin{itemize}
    \item Those that assign that simulate setting the value of a variable to a
        function of others; 
    \item Those that use IF statements that direct a program to a label if a
        predicate function of other variables is true.
\end{itemize}

A macro is not a program because it does not necessarily hold to \textbf{GOTO
law}. The formal definition of a macro is hand-wavy and long; check the source.
The variables of a macro that are only used within the macro are the
\textit{auxiliary variables}. The variables the receive the input (from within
some program) are the \textit{official variables}. 

\begin{theorem}
    Let $\Sigma$ a finite alphabet. Then if $f$ a $\Sigma$-computable function,
    there is a macro $\left[ Z \overline{n+1} \leftarrow f \left( V_1, \ldots, V
    \overline{n}, W_1, \ldots, W \overline{m}\right)  \right] $ with $Z \in
    \left\{ V, W \right\} $ depending on the value of $f$.
\end{theorem}

\textbf{Example.} The function $\mathcal{F} = \lambda xy[x + y]$ is
$\Sigma$-computable. Then there is a macro that computes it. Such macro is: 

\begin{align*}
    &V_4 \leftarrow V_2 \\ 
    &V_5 \leftarrow  V_3 \\ 
    &V_1 \leftarrow V_4 \\ 
    A_1 ~ & IF ~ V_5 \neq 0 ~ GOTO ~ A_2 \\ 
    & GOTO~ A_3 \\ 
    A_2 ~ & V_5 \leftarrow V_5 - 1 \\ 
          &V_1 \leftarrow V_1 + 1 \\ 
          &GOTO ~ A_1 \\ 
    A_3 ~ & SKIP
\end{align*}

We replace $V_1$ with that variable where the output is to be stored, $V_2, V_3$
with the variables the are to be summed, and this performs the sum of two
variables. Now, to program $\lambda xy[x \cdot y]$ we can use the following:

\begin{align*}
    L_1 ~ ~ ~ & IF ~ N_2 \neq 0 ~ GOTO ~ L_2 \\ 
              & GOTO ~ L_3 \\ 
    L_2 ~ ~ ~ & \left[ N_3 \leftarrow \mathcal{F}(N_3, N_1) \right]  \\ 
              &N_2 \leftarrow  N_2 - 1 \\ 
              &GOTO ~ L_1 \\ 
    L_3 ~ ~ ~ &N_1 \leftarrow N_3
\end{align*}


\small
\begin{quote}


\begin{problem}
    Let $\Sigma = \{@, !\}$ and $f \sim (0, 1, \#)$ a $\Sigma$-computable
    function. Let $L = \left\{ \alpha \in \mathcal{D}_f : f(\alpha) = 1 \right\}
    $. Using the macro $\left[ V_1 \leftarrow f(W_1) \right] $, give a program
    $\mathcal{P} \in Pro^{\Sigma}$ s.t. $\mathcal{D}_{\Psi_{\mathcal{P}}^{0, 1,
    \#}} = L$.
\end{problem}

$\mathcal{D}_{\Psi_{\mathcal{P}}^{0, 1, \#}} = L$ if and only if $\mathcal{P}$
halts only when starting from a state $[\![ \alpha \in L ]\!]$
Such $\mathcal{P}$ may be 

\begin{align*}
    &[N_1 \leftarrow f(P_1)]\\
    &IF ~ N_1 \neq 0 ~ GOTO  ~ L_1 \\ 
    &GOTO ~ L_2 \\ 
    L_1  ~ ~ ~ & GOTO ~ L_1 \\ 
    L_2 ~ ~ ~ & SKIP
\end{align*}

Incidentally, it is easy to observe that $\Psi_{\mathcal{P}}^{0, 1, \#} = f_{\mid L}$.

\begin{problem}
    Let $\Sigma = \{@, !\}$ and $f \sim (1, 0, *)$ a $\Sigma$-computable
    function. Using $\left[ W_1 \leftarrow f(V_1) \right] $, give a program
    $\mathcal{P} \in Pro^{\Sigma}$ s.t. $\mathcal{D}_{\Psi_{\mathcal{P}}^{1, 0,
    *}} = Im_{f}$.
\end{problem}

We require a program $\mathcal{P} \in Pro^{\Sigma}$ s.t. $\mathcal{P}$ halts
only from a starting state of the form $[\![ \alpha \in Im_f ]\!]$. Such a program
may be 

\begin{align*}
    L_1~ ~ ~&\left[P_2 \leftarrow f(N_1) \right]  \\ 
    &\left[ IF ~ P_1 = P_2 ~ GOTO ~ L_2 \right]  \\ 
    &N_1 \leftarrow N_1 + 1 \\ 
    &GOTO ~ L_1 \\ 
    L_2 ~ ~ ~ & Skip
\end{align*}

where $\left[ IF ~ W_1 = W_2 ~ GOTO ~ A_1 \right] $ is the macro

\begin{align*}
    &W_3 \leftarrow W_1  \\ 
    &W_4 \leftarrow W_2 \\ 
    A_1 ~ ~ ~ &IF ~ W_3 BEGINS ~ @ ~ GOTO ~ A_2 \\ 
    &IF ~ W_3 BEGINS ~ ! ~ GOTO ~ A_3 \\ 
    &
    A_2 ~ ~ ~ &IF~ W_4 ~ BEGINS ~ @ ~ GOTO ~ A_4 \\ 
              &GOTO ~ A_{1000}\\
    A_3 ~ ~ ~ &IF~ W_4 ~ BEGINS ~ ! ~ GOTO ~ A_4 \\ 
    A_4 ~ ~ ~ & W_3 \leftarrow {}^{\curvearrowright} W_3 \\ 
              &W_4 \leftarrow {}^{\curvearrowright} W_4 \\ 
              &GOTO A_5 \\ 
    A_{1000}~ ~ ~ & SKIP
\end{align*}

that checks if two \textit{not-empty} strings are equal and jumps to the
official label $A_5$ if the case is true.

\end{quote}
\normalsize


\subsection{Enumerable sets}

A non-empty $\Sigma$-mixed set $S$ is $\Sigma$-enumerable if and only if there are
programs $\mathcal{P}_1, \ldots, \mathcal{P}_{n + m}$ s.t. 

\begin{align*}
    \mathcal{D}_{\Psi_{\mathcal{P}_1}^{n, m, \#}} &= \ldots =
    \mathcal{D}_{\Psi_{\mathcal{P}_n}^{n, m, \#}} = \omega\\
    \mathcal{D}_{\Psi_{\mathcal{P}_{n+1}}^{n, m, *}} &= \ldots =
    \mathcal{D}_{\Psi_{\mathcal{P}_{n+m}}^{n, m, *}} = \omega
\end{align*}

and 

\begin{align*}
    S = Im ~ \left[ \Psi_{\mathcal{P}_1}^{n, m, \#}, \ldots,
    \Psi_{\mathcal{P}_n}^{n, m, \#}, \Psi_{\mathcal{P}_{n+1}}^{n, m, *},
\ldots, \Psi_{\mathcal{P}_{n+m}}^{n, m, *} \right] 
\end{align*}

In other words, for each input $x \in \omega$, the $i$th program $\mathcal{P}_i$
computes the value of the $i$th element in a tuple of $S$. Another way to put
this is 


\begin{theorem}
    If $S$ a non-empty $\Sigma$-mixed set, then it is equivalent to say: 

    \textit{(1)} $S$ is $\Sigma$-enumerable. 

    \textit{(2)} There is a $\mathcal{P} \in Pro^{\Sigma}$ satisfying the
    following two properties. $a.$ For all $x \in \omega$, $\mathcal{P}$ halts
    from $[\![ x ]\!]$ into a state of the form $[\![ x_1, \ldots, x_n,
    \alpha_1, \ldots, \alpham ]\!]$ when $(x_1, \ldots, x_n, \alpha_1, \ldots,
    \alpha_n) \in S$. \textit{b.} For any tuple $(x_1, \ldots, x_n, \alpha_1, \ldots, \alpha_m) \in
S$, there is a $x \in \omega$ s.t. $\mathcal{P}$ halts starting from $[\![ x
]\!]$ in a state of the form $[\![ x_1, \ldots, x_n, \alpha_1, \ldots, \alpha_m ]\!]$ 

\end{theorem}

When a program satisfies these properties, we say it \textit{enumerates} $S$.

\subsection{$\Sigma$-computable sets}

A $\Sigma$-mixed set $S$ is said to be $\Sigma$-computable if
$\chi_{S}^{\omega^n \times \Sigma^{*m}}$ is $\Sigma$-computable. This is, $S$ is
$\Sigma$-computable if and only if there is a $\mathcal{P} \in Pro^{\Sigma}$
s.t. $\mathcal{P}$ commputes $\chi_S^{\omega^n \times \Sigma^{*m}}$. 

Observe that this means that $\mathcal{P}$ halts with $N_1 = 1$ when starting
from $[\![ \overrightarrow{x}, \overrightarrow{\alpha} ]\!]$ if
$(\overrightarrow{x}, \overrightarrow{\alpha}) \in S$, and halts with $N_1 = 0$
otherwise. We say $\mathcal{P}$ \textit{decides} the belonging to $S$.

Observe that if $\chi_S^{\omega^n \times \Sigma^{*m}}$ is $\Sigma$-computable,
then there is a macro 

\begin{align*}
    \left[ IF ~ \chi_S^{\omega^n \times \Sigma^{*m}} \left( V_1 \ldots, V
    \overline{n}, W_1, \ldots, W \overline{m} \right) ~ GOTO ~ A_1  \right] 
\end{align*}

We will write this macro as $\left[ IF ~ (V_1, \ldots V \overline{n}, W_1, \ldots,
W \overline{m}) \in S ~ GOTO ~ A_1 \right] $. Of course, this macro is only
valid when $S$ is a $\Sigma$-computable set.

\begin{theorem}
    In Godel's paradigm, $S$ is $\Sigma$-p.r. iff it is the domain of a
    $\Sigma$-p.r. function. This statement \textit{does not hold} in von
    Neumman's paradigm. There are sets that are domains of $\Sigma$-computable
    functions that are not $\Sigma$-computable themselves.
\end{theorem}

\pagebreak 

\section{Paradigm battles}

\subsection{Neumann triumphs over Godel}

\begin{theorem}
    If $h$ is $\Sigma$-recursive then it is $\Sigma$-computable.
\end{theorem}

A corollary is that every $\Sigma$-recursive function has a corresponding macro.

\begin{theorem}
    If $S_1, S_2 \subseteq \omega^{n} \times \Sigma^{*m} $ are
    $\Sigma$-enumerable, then $S_1 \cup S_2$ is $\Sigma$-enumerable. 
\end{theorem}


\small
\begin{quote}

\textbf{Proof}. Via assumption there are $F : \omega \mapsto \omega^{n} \times
\Sigma^{*m} $, $G : \omega \mapsto \omega^{n} \times \Sigma^{*m} $ s.t.
$F_{(i)}, G_{(i)}$ are $\Sigma$-computable for every $i$ and $Im_F = S_1$, $Im_G =
S_2$. $\therefore $ $F_{(i)}, G_{(i)}$ have associated macros. 

$\lambda x \left[ x \text{ is even }  \right]$ is $\Sigma$-p.r. $\therefore $  it
is $\Sigma$-computable. $\therefore $ $\lambda x \left[ x \text{ is even }
\right]$ has an associated macro. $\therefore $ There is an IF macro which
checks if a variable holds an even number.

$\lambda x \left[ x/2  \right]$ is $\Sigma$-p.r. $\therefore $ it is
$\Sigma$-p.r. $\therefore $ it has an associated macro.

Using the macros above, one can write a program $\mathcal{P} \in Pro^{\Sigma}$
that does the following: 

\footnotesize
\begin{quote}
    If the input $N_1$ is even, set $N_1$ to its integer quotient by two and
    then let $N_1 = F_1(N_1), \ldots, N_n = F_n(N_n)$. 

    If the input $N_1$ is odd, set $N_1$ to its integer quotient by two minus
    one and then let $N_1 = G_1(N_1), \ldots, N_n = G_n(N_n)$. 
\end{quote}

It is easy to see that this satisfies the theorem of the \textbf{Enumerable
sets} section of the von Neumann paradigm.

\end{quote}
\normalsize

\begin{theorem}
    If $S \subseteq \omega^{n} \times \Sigma^{*m} $ is $\Sigma$-computable, then
    $S$ is enumerable.
\end{theorem}


\small
\begin{quote}

\textbf{Proof.} Assume $S \subseteq \omega^{n} \times \Sigma^{*m} $ is
$\Sigma$-computable. $\therefore $ $\Chi_{S}^{n, m}$ is $\Sigma$-recursive and
has an associated macro.

Recall that $pr : \mathbb{N} \mapsto \omega$ is
$\Sigma$-p.r. $\therefore $ $pr$ is $\Sigma$-recursive and has an associated
macro. The same is true of $\leq^{*}$, since its definition involves only string
concatenations and string exponentiations (which are $\Sigma$-p.r.) on two
mutually exclusive cases. 

Let

\begin{align*}
    \mathcal{F} : [1, m]  \times \mathbb{N} &\mapsto \omega \cup \Sigma^{*}  \\ 
    (x, i) &\mapsto \begin{cases}
        (x)_i & 1 \leq i \leq n \\
        *^{\leq} \left( (x)_i \right) & n + 1 \leq i \leq m
    \end{cases}
\end{align*}

The program $\mathcal{P}_i$ with input $x, i$ defined as

\begin{align*}
   &[N_2 \leftarrow pr(N_2)] \\
    L_1 ~ ~ ~ &[IF \neg (N_2 \mid N_1) ~ GOTO ~ L_2] \\
              & N_3 \leftarrow N_3 + 1 \\ 
              & [N_2 \leftarrow N_2 \times N_2] \\ 
              & GOTO ~ L_1 \\ 
    L_2 ~ ~ ~ & [IF 1~ \leq N_1 \leq m ~ GOTO ~ L_{3}]\\
    & [N_1 \leftarrow *^{\leq}(N_3)] \\ 
              &GOTO ~ L_{100} \\
    L_3 ~ ~ ~ & N_1 \leftarrow N_3 \\ 
    L_{100} ~ ~ ~ & SKIP
\end{align*}

when $n + 1 \leq i \leq m$ computes $\mathcal{F}$. $\therefore $ There is a
macro for $\mathcal{F}$.

Let $u = n + m + 1$ and $\mathcal{P}$ the following program:

\begin{align*}
    &N \overline{u} \leftarrow N_1\\
    &[N_1 \leftarrow \mathcal{F}(N \overline{u}, 1)] \\
    &[N_2 \leftarrow \mathcal{F}(N \overline{u}, 2)] \\ 
    &\vdots \\
    &[P_{\overline{m}} \leftarrow \mathcal{F}(N \overline{u}, n+m)] \\
    &[IF ~ \chi_s^{n, m} \left( N_1, \ldots, N_{\overline{n}}, P_{\overline{m}},
    \right) ~ GOTO ~ L_{100}] \\
    L_{0} ~ ~ ~ & GOTO ~ L_0 \\ 
    L_{100} ~ ~ ~ & SKIP
\end{align*}

\textit{a.} For any $x \in \omega$, $\mathcal{P}$ halts at a state with
instantaneous description $[\![ x_1, \ldots, x_n, \alpha_1, \ldots, \alpha_m
]\!]$ with $(x_1, \ldots, x_n, \alpha_1, \ldots, \alpha_n) \in S$; \textit{b}.
for any $(\vec{x}, \vec{\alpha}) \in S$ there is some $x \in \omega$ s.t.
$\mathcal{P}$ halts at $[\![ (\vec{x}, \vec{\alpha})  ]\!]$ when starting from
$x$. $\therefore $ $\mathcal{P}$ enumerates $S$.

\begin{problem}
    Prove that, if $S \subseteq \Sigma^{*}$ is $\Sigma$-enumerable, then 

    \begin{align*}
        T = \left\{ \alpha \in \Sigma^{*}: \exists \beta \in S :  \alpha
        \text{ is subchain of } \beta\right\} 
    \end{align*}

    is $\Sigma$-enumerable. 

\end{problem}

Let $\mathcal{F} : \omega \mapsto \Sigma^{*}$ denote the function which
enumerates $S$, which is $\Sigma$-computable and has a macro. The key to the
problem is to observe that, per each $\alpha \in S$, there are $|\alpha| - 1$
subchains of $\alpha$ in $T$. Thus, for $\mathcal{F}(i)$ we want to enumerate
 $|\mathcal{F}(i)| - 1$ subchains. 

 I provide a program that accomplishes this and then illustrate its operation on
 a finite alphabet. It is easy to verify that the program enumerates $T$ and
 that this enumeration holds for infinite alphabets as well.

Let $\mathcal{P}$
with input $x \in \omega$ be 

\begin{align*}
    &[P_1 \leftarrow \mathcal{F}(N_3)] \\ 
    &[N_{50} \leftarrow  |\mathcal{F}(N_3)|] \\
    L_1 ~ ~ ~ &[IF ~ N_1 \geq N_{50} ~ GOTO ~ L_2] \\ 
              & N_{10} \leftarrow N_{50} - N_1\\
              & N_{10} \leftarrow N_{10} - 1\\
    L_{11} ~ ~ ~ & [P_1 \leftarrow {}^{\curvearrowleft} P_1]\\ 
              & N_{10} \leftarrow  N_{10} - 1 \\ 
              & [IF ~ N_{10} = 0 ~ GOTO ~ L_{100} ]\\ 
              &GOTO ~ L_{11}\\
    L_2 ~ ~ ~ &N_3 \leftarrow N_3 + 1 \\ 
    &[P_1 \leftarrow \mathcal{F}(N_3)] \\ 
              &[N_{50} \leftarrow N_{50} + |P_1|] \\ 
              &GOTO ~ L_1\\
    L_{100} ~ ~ ~ &SKIP
\end{align*}

\footnotesize
\textit{Example.}Let $S = \{ abab, bba, bbba, abb\}$. Then the program can be
illustrated as follows:

\begin{align*}
    &x = 0 \mid  \overbrace{0 \leq 4}^{N_{50} \leq N_1} \mid N_{10} = 3 \mapsto a \\
    &x = 1 \mid 1 \leq 4 \mid N_{10} = 2 \mapsto ab \\
    &x = 2 \mid  2 \leq 4 \mid N_{10} = 1 \mapsto aba \\
    &x = 3 \mid   3 \leq 4 \mid N_{10} = 0 \mapsto aba \\
\end{align*}

When $x = 4$, we have $N_{50} \geq N_1$ and so $P_1$ becomes $bba, N_{50}$
becomes $4 + 3 = 7$ and

\begin{align*}
    &x = 4 \mid  \overbrace{4 \leq 7}^{N_{50} \leq N_1} \mid N_{10} = 2  \mapsto
    b\\
    &x = 5 \mid  5 \leq 7 \mid N_{10} = 1  \mapsto
    bb\\
    &x = 6 \mid  6 \leq 7 \mid N_{10} = 0  \mapsto
    bb\\
\end{align*}

When $x = 7$, the $L_{2}$ case is met twice, and so $P_1 = bbba, N_{50} = 4 + 3
+ 4 = 11$ and

\begin{align*}
    &x = 7 \mid  \overbrace{7 \leq 11}^{N_{50} \leq N_1} \mid N_{10} = 3  \mapsto
    b\\
    &x = 8 \mid  {8 \leq 11} \mid N_{10} = 2  \mapsto
    bb\\
    &x = 9 \mid  {9 \leq 11} \mid N_{10} = 1  \mapsto
    bbb\\
    &x = 10 \mid  {10 \leq 11} \mid N_{10} = 0  \mapsto
    bbb\\
\end{align*}

etc. Thus, the program enumerates $S$ and, per each $\alpha \in S$, it
enumerates the substrings which make up $\alpha$. The program is s.t. 

\begin{align*}
    &\begin{rcases}
        &0 \mapsto \textit{The smallest substring of $\mathcal{F}(0)$} \\
        &1 \mapsto \textit{The next smallest substring of $\mathcal{F}(0)$} \\
        &2 \mapsto \textit{The next smallest substring of $\mathcal{F}(0)$} \\
        &3 \mapsto \textit{The next  smallest of $\mathcal{F}(0)$} \\
    \end{rcases}
    \text{$0\leq x \leq |\mathcal{F}(0)|$}\\
    &\begin{rcases}
        &4 \mapsto \textit{The smallest substring of $\mathcal{F}(1)$} \\
        &5 \mapsto \textit{The next smallest $\mathcal{F}(1)$} \\
        &6 \mapsto \textit{The next smallest substring of $\mathcal{F}(1)$} \\
    \end{rcases}
    \text{$|\mathcal{F}(0)| \leq x \leq |\mathcal{F}(0)\mathcal{F}(1)|$} \\ 
    &\vdots 
\end{align*}

\end{quote}
\normalsize

\subsection{Godel triumphs over Neumann}

The following three functions contain all the information relevant to
$\mathcal{S}^{\Sigma}$. Assuming $n, m \in \omega$ are fixed, 

\begin{align*}
    i^{n, m} & \omega \times \omega^n \times \Sigma^{*m} x Pro^{\Sigma} \mapsto
    \omega \\
    E_{\#}^{n, m} & \omega \times \omega^n \times \Sigma^{*m} x Pro^{\Sigma} \mapsto
    \omega^{[\mathbb{N}]} \\
    E_{*}^{n, m} & \omega \times \omega^n \times \Sigma^{*m} x Pro^{\Sigma} \mapsto
    \Sigma^{*}^{[ \mathbb{N} ]} \\
\end{align*}

For brevity, let $f^{n, m}(t, \vec{x}, \vec{a}, \mathcal{P}) = f(t)$ for $f \in \left\{
i^{n, m}, E_\#^{n, m}, E_*^{n, m}\right\} $---this is, let as assume fixed
$\vec{x}, \vec{\alpha}, \mathcal{P}$. Then

\begin{align*}
    \left( i^{n, m}(0), E_{\#}^{n, m}(0), E_{*}^{n, m}(0) \right) &= \left( 1,
    \left( x_1, \ldots, x_n, 0, \ldots \right), \left( \alpha_1, \ldots,
\alpha_n, 0, \ldots \right)   \right)  \\ 
        \left( i^{n, m}(t+1), E_{\#}^{n, m}(t+1), E_{*}^{n, m}(t+1) \right) &=
        S_{\mathcal{P}}\left( i^{n, m}(t), E_{\#}^{n, m}(t), E_{*}^{n, m}(t)
   \right)  \\ 
\end{align*}

It is clear that $\left( i^{n, m}(t, \vec{x}, \vec{\alpha}, \mathcal{P}),
E_{\#}^{n, m}(t, \vec{x}, \vec{\alpha}, \mathcal{P}), E_{*}^{n,m}(t, \vec{x},
\vec{\alpha}, \mathcal{P}) \right) $ is the instantaneous description of
$\mathcal{P}$ after $t$ steps starting from $[\![ \vec{x}, \vec{\alpha} ]\!]$.

The $E$ functions are not $( \Sigma \cup \Sigma_p )$-mixed, but if we define $E^{n, m}_{\varphi
j}$, with $\varphi \in \{*, \#\}$, as the $j$th coordinate of $E^{n,
m}_{\varphi}$, we find that $E_{\varphi j}^{n, m}$ is $( \Sigma \cup \Sigma_p )$-mixed.

\begin{theorem}
    The functions $i^{n, m}, E_{\varphi j}^{n, m}$ are $(\Sigma \cup \Sigma_p)$-mixed functions.
\end{theorem}

Given $n, m \in  \omega$, we define 

\begin{align*}
    Halt^{n, m} = \lambda t\vec{x}\vec{\alpha} \mathcal{P} \left[ i^{n, m}(t,
    \vec{x}, \vec{\alpha}, \mathcal{P}) = n(\mathcal{P}) + 1  \right]
\end{align*}

Observe that $\mathcal{D}_{Halt} = \omega \times \omega^{n} \times \Sigma^{*m}
\times Pro^{\Sigma}$.

\begin{theorem}
    $Pro^{\Sigma}$ is a $( \Sigma \cup \Sigma_p )$-p.r. set and $n(\mathcal{P}),
    I_{j}^{\mathcal{P}}$ are $( \Sigma \cup \Sigma_p )$-p.r. functions.
\end{theorem}

\begin{theorem}
    The $Halt$ function is $\Sigma$-p.r. 
\end{theorem}


\small
\begin{quote}

\textbf{Proof.} Observe that 

\begin{align*}
    Halt^{n, m} = \lambda xy \left[ x = y  \right] \circ \left[ i^{n, m},
    \lambda \mathcal{P} \left[ n(\mathcal{P})  \right] \circ p_{n+m+2}^{1+n, m +
1} \right] 
\end{align*}

\end{quote}
\normalsize

We define $T^{n, m} = M(Halt^{n, m})$. Observe that 

$$\mathcal{D}_T^{n, m} =
\left\{ (\vec{x}, \vec{\alpha}, \mathcal{P}) \in \omega^{n} \times \Sigma^{*m} : \mathcal{P}
\text{ halts when starting from } [\![ (\vec{x}, \vec{\alpha})  ]\!]\right\} $$

\begin{theorem}
    $T^{n, m}$ is $( \Sigma \cup \Sigma_p )$-recursive but it is not $( \Sigma
    \cup \Sigma_p )$-p.r. 
\end{theorem}

The previous theorem follows from the fact that $T^{n, m}$ is a minimization
over a $\Sigma$-p.r. predicate.

\begin{theorem}
    If $f$ is a $\Sigma$-computable $\Sigma$-mixed function, then $f$ is
    $\Sigma$-recursive.
\end{theorem}

The previous theorem states that any function computable in von Neumman's
paradigm is computable in Godel's paradigm.


\small
\begin{quote}

\textbf{Proof}. The proof consists in showing that $f$ is $( \Sigma \cup
\Sigma_p )$-recursive. Then, due to the alphabet independence of recursion, it
is $\Sigma$-recursive.

\end{quote}
\normalsize

\subsection{Interacting programs}

Using the results of the previous section, we can construct programs that depend
on other programs. This is illustrated with an example. Say $\Sigma \left\{ @, +
\right\} $ and $\mathcal{P}_0 \in Pro^{\Sigma}$ is s.t. $0 \in
\mathcal{D}_{\Psi_{\mathcal{P_0}}^{1, 0, \#}}$ with $\Psi_{\mathcal{P}_0}^{1, 0,
\#}(0) = 2$. We will show 

\begin{align*}
    S = \left\{ x \in \mathcal{D}_{\Psi_{\mathcal{P}_0}^{1, 0, \#}} :
    \Psi_{\mathcal{P}_0}^{1, 0, \#}(x) \neq 0\right\} 
\end{align*}

is $\Sigma$-enumerable. 

The program will do the following. For each input $x$, it will test whether
$\mathcal{P}_0$ halts when starting from $[\![ (x)_1 ]\!]$ in $(x)_2$ steps. If
it doesn't it will simply return zero (since $0 \in S$). If it does, it will
compute $\mathcal{P}_0$ starting from $[\![ (x)_1 ]\!]$; if the output is not
zero, it will return it. If it is zero, it will return $0$. 

Of course, the program will make use of the $Halt^{1, 0}$ function, which is
$\Sigma$-recursive and thus has an associated macro. It will also use $E_{#
j}^{1, 0}$ to retrieve the output of $\mathcal{P}_0$ after $(x)_2$ steps. This
function is also $\Sigma$-p.r. and thus it also has an associated macro. The
program is 

\begin{align*}
    &IF ~ N_1 \neq 0 ~ GOTO ~ L_1 \\ 
    &GOTO ~ L_2 \\ 
    L_1 ~ ~ ~ & [N_3 \leftarrow (N_1)_1] \\
              &[N_4 \leftarrow (N_1)_2] \\ 
              &[IF ~ Halt^{1, 0}(N_4, N_3, \mathcal{P}_0) ~ GOTO ~ L_3] \\ 
              &GOTO ~ L_2 \\ 
    L_3 ~ ~ ~ & \left[ N_5 \leftarrow E_{1}^{1, 0} (N_4, N_3, \mathcal{P}_0)
    \right]  \\  
              &[IF ~ N_5 = 0 ~ GOTO ~ L_2] \\ 
              &N_1 \leftarrow  N_5 \\ 
              &GOTO ~ L_4 \\ 
        L_2 ~ ~ ~ & N_1 \leftarrow  0 \\ 
        L_4 ~ ~ ~ & SKIP
\end{align*}

Thus, a program may use another program to operate.

\begin{theorem}
    If $S$ a $\Sigma$-mixed set then these statements are equivalent: 

    \textit{(1)} $S$ is $\Sigma$-enumerable 

    \textit{(2)} $S = I_F$ for $F : \mathcal{D}_F \subseteq  \omega^{n} \times
    \Sigma^{*m} \mapsto S$ s.t. $F_{(i)}$ is $\Sigma$-computable for each $i =
    1,\ldots, n+m$. 

    \textit{(3)} $S$ is the domain of a $\Sigma$-computable function.
\end{theorem}


\small
\begin{quote}

\textbf{Proof}. $(1) \Rightarrow (2)$ Assume $S$ is $\Sigma$-enumerable. Then
there are programs $\mathcal{P}_1, \ldots, \mathcal{P}_{n+m}$ s.t. $S =
\text{Image of } \left[
\Psi_{\mathcal{P}_1}^{n, m, \#}, \ldots, \Psi_{\mathcal{P}_{n+m}}^{n,
m,*}\right] $. Let $f = \left[ \Psi_{\mathcal{P}_1}^{n, m, \#}, \ldots,
\Psi_{\mathcal{P}_{n+m}}^{n, m,*}\right] \right] $. $\blacksquare$

$(2) \Rightarrow (3)$ Assume $S = I_F$  with $F$ a function satisfying the
specifications of the theorem. Let $\mathcal{P}_i \in Pro^{\Sigma}$ denote the program that
computes $F_{(i)}$. It is possible to construct a program that, from an initial
state $[\![ (\vec{x}, \vec{\alpha})  ]\!]$, does the
following: 

\begin{quote}

    \textit{(0)} Let $N_{n+1} \leftarrow 1$. 

    \textit{(1)} Evaluate whether each $\mathcal{P}_i$ with initial state

    $$[\![  (x_{n+1})_1,
    \ldots, (x_{n+1})_n, (*^{\leq}(\alpha_{m+1}))_1, \ldots,
    (*^{\leq}(\alpha_{m+1}))_m ]\!]
    $$ 

    halts in $t = (x_{n+1})_{n+1}$ steps. 

    \textit{(2)} If the programs halt, proceed to step \textit{(3)}. Else let
    $N_1 \leftarrow N_1 + 1$ and return to \textit{(1)}.

    \textit{(3)} Let $N_{n+i}$ store the output of $\mathcal{P}_i$ for $1 \leq i
    \leq n$, and $P_{m+i}$ store the output of $\mathcal{P}_i$ for $n+1 \leq i
    \leq m$.

    \textit{(4)} If $N_{n+i} = N_{i} \land P_{m+i} = P_i$ for all $1 \i \leq
    n+m$ return 1. Else loop forever.

\end{quote}

The reader may implement this program in the $\mathcal{S}^{\Sigma}$ language
using the $Halt$ function. The program attempts to (and must eventually succeed
at) generating an element of $S$ using the $F_{(1)}, \ldots, F_{(n+m)}$
functions. It then compares whether the values of the input state are equal to
the generated element of $S$. If this is true, then it outputs $1$. Otherwise it
loops forever. It is evident that the program computes $\left(\lambda \vec{x}\vec{\alpha}
    \left[ 1 \right])_{\mid S}$. $\blacksquare$

    $(3) \Rightarrow (1)$ Assume $S$ is the domain of a $\Sigma$-computable
    function $f$. One can construct a program that does the following: Given a
    fixed $w \in S$ and a starting state $[\![ x ]\!]$,

    \begin{quote}
        \textit{(0)} If $N_1 = 0$ set $N_1 \leftarrow  w$ and finish.

        \textit{(1)} Check if $\mathcal{P}_f$ halts starting from 

        $$[\![ (N_1)_1,
        \ldots, (N_1)_{n}, *^{\leq} \left( (N_1)_{n+1} \right), \ldots, *^{\leq}
        \left( (N_1)_{n+m} \right) ]\!]$$

        in $(N_1)_{n+m+1}$ steps. If it does not, set $N_1 \leftarrow  N_1 + 1$
        and go to \textit{(1)}; else continue. 

        \textit{(2)} Set $N_1, \ldots, N_n, P_1, \ldots, P_m$ so that the final
        state is 

        $$[\![ (N_1)_1,
        \ldots, (N_1)_{n}, *^{\leq} \left( (N_1)_{n+1} \right), \ldots, *^{\leq}
        \left( (N_1)_{n+m} \right) ]\!]$$

        and finish.
    \end{quote}

    This program is easy to implement in $\mathcal{S}^{\Sigma}$. It is evident
    that it enumerates $\mathcal{D}_f = S$.

\end{quote}
\normalsize


\small
\begin{quote}

\begin{problem}
    Let $\Sigma = \left\{ @, + \right\} $ and $f : \mathcal{D}_f \subseteq
    \Sigma^{*} \mapsto \omega$ a $\Sigma$-computable function s.t.
    $f(\varepsilon ) = 1$. Let 

    \begin{align*}
        L = \left\{ \alpha \in D_f : f(\alpha) = 1 \right\} 
    \end{align*}

    Provide a program $\mathcal{Q} \in Pro^{\Sigma}$ that enumerates $L$.
\end{problem}

Let $\mathcal{P} \in Pro^{\Sigma}$ be the program that computes $f$. Our program
$\mathcal{Q}$, given a starting state $[\![ x ]\!]$, may operate as follows: 

\begin{quote}
    \textit{(0)} Check if the input is zero; if it is return $\varepsilon $. (This
    is important because we will generate strings with the $*^{\leq}$ function,
    which never maps to $\varepsilon$---without this condition our program would
    never enumerate $\varepsilon$!)
    \textit{(1)} Compute $\beta := *^{\leq}\left( (x)_1 \right), (x)_2$.

    \textit{(2)} If $\mathcal{P}$ halts in $(x)_2$ steps starting from $\beta$, compute
    it and go to next step; else return $\varepsilon$ (since $\varepsilon \in  L$).  

    \textit{(3)} If the output of $\mathcal{P}$ was $1$ return $\beta$; else return
    $\varepsilon$.
\end{quote}

\begin{align*}
    &[IF ~ N_1 = 0 ~  GOTO ~ L_2] \\
    &\left[P_1 \leftarrow *^{\leq} \left( (N_1)_1 \right) \left] \\ 
    &\left[N_1 \leftarrow (N_1)_2 \right] \\  
    &[IF ~ Halt^{0, 1} \left( N_1, P_1, \mathcal{P} \right) ~ GOTO ~ L_1 ] \\ 
    &GOTO ~ L_2 \\ 
    L_1 ~ ~ ~ & \left[ N_2 \leftarrow E_{* 1}^{0, 1} \left( N_1, P_1,
    \mathcal{P} \right)  \right]  \\ 
              &[IF ~ N_2 = 1 ~ GOTO ~ L_{10}] \\ 
    L_2 ~ ~ ~ &P_1 \leftarrow  \epsilon \\  
    L_{10} ~ ~ ~ & SKIP
\end{align*}


\begin{problem}
    Let $\Sigma = \left\{ @, + \right\} $ and $\mathcal{P}_0 \in Pro^{\Sigma}$.
    Show that 

    \begin{align*}
        S = \left\{ ({x}, {\alpha}) : \Psi_{\mathcal{P}_0}^{1, 0, \#}(x)
        = \Psi_{\mathcal{P}_0}^{0, 1, \#}(\alpha)\right\} 
    \end{align*}

    is $\Sigma$-enumerable.
\end{problem}

The program may operate as follows. Given an initial state $[\![ x ]\!]$,

\begin{quote}
    \textit{(1)} Find $(x)_1, (x)_2$. 

    \textit{(2)} Evaluate whether $\mathcal{P}$ halts in $(x)_2$ steps from
    $[\![ (x)_1 ]\!]$. If it does not, let $x = x + 1$ and return to
    \textit{(1)}. If it does go to \textit{(3)}. 

    \textit{(3)} Find $\alpha = *^{\leq} \left( (x)_3 \right), (x)_4 $.  

    \textit{(4)} Evaluate whether $\mathcal{P}$ halts in $(x)_4$ steps from
    $[\![ \alpha ]\!]$. If it doesn't let $x = x+ 1$ and to $\textit{(1)}$; it it does go to
    \textit{(5)}. 

    \textit{(5)} Check whether the computation of $\mathcal{P}$ from $[\![ (x)_1
    ]\!]$ is the same as the computation of $\mathcal{P}$ from $[\![ \alpha
    ]\!]$. If it is not, let $x = x + 1$ and go to \textit{(1)}, else go to
    $(6)$. 

    \textit{(6)} Set $N_1 \leftarrow (x)_1, P_1 \leftarrow  \alpha$.
\end{quote}

\begin{align*}
    L_0~ ~ ~ &[N_{11} \leftarrow (N_1)_1]\\
    &[N_{12} \leftarrow (N_1)_2]\\
    &[IF ~ Halt^{1, 0} \left( N_{12}, N_{11}, \mathcal{P} \right) ~ GOTO ~ L_1 ]
    \\ 
    &N_1 \leftarrow N_1 +1 \\ 
    &GOTO ~ L_0 \\ 
    L_1 ~ ~ ~ &\left[ P_{11} \leftarrow *^{\leq} \left( (N_1)_3 \right)  \right]
    \\  
              &\left[ N_{14} \leftarrow (N_1)_4 \right]  \\ 
              &\left[ IF ~ Halt^{0, 1} \left( N_{14}, P_{11}, \mathcal{P}
              \right) ~ GOTO ~ L_2  \right]  \\ 
              &N_1 \leftarrow  N_1 + 1 \\ 
              &GOTO ~ L_0 \\ 
    L_2 ~ ~ ~ &\left[ IF ~ E_{\# 1}^{1, 0} (N_{12}, N_{11}, \mathcal{P}) =
    E_{\#, 1}^{0, 1} \left( N_{14}, P_{11}, \mathcal{P} \right) ~ GOTO ~ L_{3}
\right]  \\ 
              &N_1 \leftarrow  N_1 + 1 \\ 
              &GOTO ~ L_0 \\ 
    L_4 ~ ~ ~ & N_1 \leftarrow N_{11} \\ 
              &P_1 \leftarrow P_{11}
\end{align*}

\pagebreak
\begin{problem}
    If $S \subseteq \omega$ and $f : S \mapsto \omega$ is $\Sigma$-computable, then 

    \begin{align*}
        W = \left\{ x \in S : x \text{ is even } \land x / 2 \in S \land f(x) =
        f(x / 2)\right\} 
    \end{align*}

    is $\Sigma$-enumerable.
\end{problem}

There is some $\mathcal{P}_f \in Pro^{\Sigma}$ that computes $f$. $\therefore S$
is $\Sigma$-enumerable via some $\mathcal{P}_S \in Pro^{\Sigma}$. Let $w \in W$
an arbitrary element.

\begin{align*}
    &[IF ~ N_1 = 0 ~ GOTO ~ L_{666}]\\
    &[N_2 \leftarrow (N_1)_1] \\
    &[N_3 \leftarrow (N_1)_2] \\
    &[N_4 \leftarrow \mathcal{P}_S(N_2)] \\ 
    &[N_5 \leftarrow \mathcal{P}_S(N_3)] \\ 
    &[IF ~ N_4 ~ \text{is odd } GOTO ~ L_{666}] \\ 
    &[IF \neg(N_5 = N_4 / 2) ~ GOTO ~ L_{666} ] \\ 
    &[IF ~ f(N_5) \neq f(N_4) ~ GOTO ~ L_^{666}] \\ 
    &N_1 \leftarrow N_2 \\ 
    &GOTO ~ L_1 \\ 
    L_{666} ~ ~ ~ &[N_1 \leftarrow  w] \\ 
    L_1 ~ ~ ~ &SKIP
\end{align*}

The program starting from $[\![ x ]\!]$ generates two elements of $s_1, s_2 \in S$ using
$(x)_1, (x)_2$---unless $x = 0$, where it just outputs $w$. If $s_1$ is even,
and $s_2 = s_1 / 2$, and $f\left( s_1 \right) = f( s_2 ) $, it outputs $s_1$.
Else it outputs $w$. It is clear that the program enumerates $W$.

\begin{problem}
    Let $\Sigma = \left\{ @, + \right\} $ and $\mathcal{P}_0 \in Pro^{\Sigma}$.
    Prove that 

    \begin{align*}
        W = \left\{ (x, \alpha, \beta) \in \omega \times \Sigma^{*}\times \Sigma^{*}
        : \mathcal{P}_0 \text{ halts from } [\![ x, \alpha, \beta ]\!]\right\} 
    \end{align*}

    is $\Sigma$-enumerable.
\end{problem}

Observe that $W = \mathcal{D}_f$ where $f = \Psi_{\mathcal{P}_0}^{1, 2, \#}$. We
have already proven that the domain of a $\Sigma$-computable function is
$\Sigma$-enumerable. Then $W$ is $\Sigma$-enumerable.  

If the program is still desired, let $(w, \alpha, \beta) \in \mathcal{D}_f$ an
arbitrary element of the domain of $f$. Then

\begin{align*}
    &[IF ~ N_1 = 0 ~ GOTO ~ L_{666}]\\
    &[N_2 \leftarrow (N_1)_1] \\
    &[P_1 \leftarrow *^{\leq}\left( (N_1)_2 \right) ] \\
    &[P_2 \leftarrow *^{\leq}\left( (N_1)_3 \right) ] \\
    &[N_3 \leftarrow (N_1)_4] \\
    &[IF ~ \neg \left(Halt^{1, 2}(N_3, N_2, P_1, P_2, \mathcal{P}_f)\right) ~
    GOTO ~ L_{666}] \\ 
    &N_1 \leftarrow N_2 \\ 
    &GOTO ~ L_1 \\ 
    L_{666} ~ ~ ~ &[N_1 \leftarrow  w] \\ 
                  &[P_1 \leftarrow \alpha] \\ 
    &[ P_2 \leftarrow \beta ] \\ 
    L_1 ~ ~ ~ &SKIP
\end{align*}

enumerates $W$.

\begin{problem}
    Let $\Sigma = \left\{ @, + \right\} $ and $\mathcal{P}_0 \in  Pro^{\Sigma}$.
    Let 

    \begin{align*}
        L = \left\{ \alpha \in \Sigma^{*} : (\exists x \in \mathbb{N})
        ~ \Psi_{\mathcal{P}_0}^{1, 1, \#}(x^2, \alpha) = \Psi_{\mathcal{P}_0}^{0,
    2, \#}(\alpha, \alpha) \right\} 
    \end{align*}

    Provide a program $\mathcal{P} \in Pro^{\Sigma}$ s.t.
    $\mathcal{D}_{\Psi_{\mathcal{P}}^{1, 0, *}} = \omega$ and
    $\mathcal{I}_{\Psi_{\mathcal{P}}^{1, 0, *}} = L$.
\end{problem}

Let $f = \Psi_{\mathcal{P}_0}^{1, 1, \#}, g = \Psi_{\mathcal{P}_0}^{0, 2, \#}$,
which have associated macros by virtue of being $\Sigma$-computable. $L$ is the
set of strings $\alpha \in \Sigma^{*}$ s.t. some $x \in \mathbb{N}$ satisfies
$f(x^2, \alpha) = g(\alpha, \alpha)$. Given an arbitrary $\varphi \in L$ and a
starting state $[\![ x ]\!]$we can construct $\mathcal{P}$ as follows:

\begin{quote}
    \textit{(0)} If $N_1 = 0$ return $\varphi$ and finish.

    \textit{(1)} Let $N_1 \leftarrow (N_1)_1, P_1 \leftarrow *^{\leq}\left( (N_1)_2 \right) $. 

    \textit{(2)} Let $N_3 \leftarrow (N_1)_3, N_4 \leftarrow (N_1)_4$.

    \textit{(3)} Evaluate whether $\mathcal{P}_0$ halts with input $[\![ N_1^2,
    P_1]\!]$ in $N_3$ steps. Evaluate whether $\mathcal{P}_0$ halts with input
    $[\![ P_1, P_1 ]\!]$ in $N_4$ steps. If both are true continue, else
    set $P_1 \leftarrow \varphi$ and finish.

    \textit{(4)} Evaluate whether $f( N_1^2 , P_1 ) = g(P_1, P_1)$. If false,
    set $P_1 \leftarrow \varphi$ and finish. Else continue. 

    \textit{(5)} Finish.
\end{quote}

Since $\left( (x)_1, *^{\leq} \left( (x)_2 \right), (x)_3, (x)_4  \right) $ over
$x = 1, 2, \ldots$ explores all possible tuples $(x, \alpha, t_1, t_2) \in
\omega \times \Sigma^{*} \times \omega \times \omega$, the program enumerates
$L$.

\end{quote}
\normalsize

Since every $\mathcal{P} \in Pro^{\Sigma}$ is a word in $\Sigma \cup \Sigma_p$,
we can enumerate sets of programs $\mathscr{P} \subseteq (\Sigma \cup
\Sigma_p)^{*}$. The enumeration of a set of programs is no different to the
enumeration of any set of words. For example, say we want to enumerate 

\begin{align*}
    \mathscr{P} = \left\{ \mathcal{P} \in Pro^{\Sigma} : \Psi_{\mathcal{P}}^{n,
    m, \#}(10) = 10 \right\} 
\end{align*}

Observe that $SKIP \in (\Sigma \cup \Sigma_p)$ and the program $\mathcal{P} =
SKIP \in \mathscr{P}$. Thus, an enumeration starting at $[\![ x ]\!]$ can
proceed as follows:

\begin{quote}
    \textit{(1)} If $x = 0$ let $P_1 \leftarrow SKIP$ and finish. 

    \textit{(2)} Take $\alpha = *^{\leq} \left( (x)_1 \right), \varphi = (x)_2 $.  

    \textit{(3)} If $\alpha \in Pro^{\Sigma}$ and $\mathcal{P}$ halts at a state
    $[\![ 10 ]\!]$ when starting from $[\![ 10 ]\!]$ and in $\varphi$ steps,
    let $P_1 \leftarrow \alpha$. Else let $P_1 \leftarrow  SKIP$.
\end{quote}

\subsection{More relationships between the paradigms}

\begin{theorem}
    If a $\Sigma$-mixed function $f$ is $\Sigma$-Turing computable then it is
    $\Sigma$-recursive.
\end{theorem}






\end{document}


